"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const path = require("path");
const chalk_1 = require("chalk");
const Debug = require("debug");
const lodash = require("lodash");
const guards_1 = require("../guards");
const fs_1 = require("@ionic/cli-framework/utils/fs");
const http_1 = require("./utils/http");
const npm_1 = require("./utils/npm");
const debug = Debug('ionic:cli-utils:lib:plugins');
exports.ERROR_PLUGIN_NOT_INSTALLED = 'PLUGIN_NOT_INSTALLED';
exports.ERROR_PLUGIN_INVALID = 'PLUGIN_INVALID';
const KNOWN_PLUGINS = ['proxy'];
const ORG_PREFIX = '@ionic';
const PLUGIN_PREFIX = 'cli-plugin-';
function formatFullPluginName(name) {
    return `${ORG_PREFIX}/${PLUGIN_PREFIX}${name}`;
}
exports.formatFullPluginName = formatFullPluginName;
function registerPlugin(env, plugin) {
    env.plugins[plugin.meta.pkg.name] = plugin;
}
exports.registerPlugin = registerPlugin;
function loadPlugins(env) {
    return tslib_1.__awaiter(this, void 0, void 0, function* () {
        const global = !env.meta.local;
        const config = yield env.config.load();
        const { npmClient } = config;
        const modulesDir = path.resolve(global ? path.dirname(path.dirname(path.dirname(env.meta.libPath))) : path.join(env.project.directory, 'node_modules'));
        const pluginPkgs = yield Promise.all(KNOWN_PLUGINS
            .map(formatFullPluginName)
            .map((pkgName) => tslib_1.__awaiter(this, void 0, void 0, function* () {
            const pluginPath = path.resolve(modulesDir, path.normalize(pkgName));
            const exists = yield fs_1.pathExists(pluginPath);
            return [pkgName, exists];
        })));
        const [, proxyVar] = http_1.getGlobalProxy();
        if (proxyVar) {
            const proxyPluginPkg = formatFullPluginName('proxy');
            debug(`Detected ${chalk_1.default.green(proxyVar)} in environment`);
            if (!pluginPkgs.find(v => v[0] === proxyPluginPkg && v[1])) {
                const proxyInstallArgs = yield npm_1.pkgManagerArgs({ npmClient, shell: env.shell }, { command: 'install', pkg: proxyPluginPkg, global });
                env.log.warn(`Detected ${chalk_1.default.green(proxyVar)} in environment, but to proxy CLI requests, you'll need ${chalk_1.default.cyan(proxyPluginPkg)} installed.\n` +
                    `You can install it by running:\n\n${chalk_1.default.green(proxyInstallArgs.join(' '))}\n`);
            }
        }
        const pluginPromises = pluginPkgs.map((pkg) => tslib_1.__awaiter(this, void 0, void 0, function* () {
            const [pkgName, exists] = pkg;
            if (exists) {
                try {
                    return yield loadPlugin(env, pkgName, { global });
                }
                catch (e) {
                    if (e !== exports.ERROR_PLUGIN_INVALID) {
                        throw e;
                    }
                }
            }
        }));
        const infofns = [];
        for (const p of pluginPromises) {
            const plugin = yield p;
            if (plugin) {
                registerPlugin(env, plugin);
                if (plugin.getInfo) {
                    infofns.push(plugin.getInfo);
                }
            }
        }
        const originalGetInfo = env.getInfo;
        env.getInfo = () => tslib_1.__awaiter(this, void 0, void 0, function* () {
            const infos = lodash.flatten(yield Promise.all(infofns.map(f => f())));
            return [...infos, ...yield originalGetInfo()];
        });
    });
}
exports.loadPlugins = loadPlugins;
function determineDistTag(version) {
    if (version.includes('-alpha')) {
        return 'canary';
    }
    if (version.includes('-testing')) {
        return 'testing';
    }
    return 'latest';
}
exports.determineDistTag = determineDistTag;
function loadPlugin(env, pluginName, { global = false }) {
    return tslib_1.__awaiter(this, void 0, void 0, function* () {
        const modulesDir = path.resolve(global ? path.dirname(path.dirname(path.dirname(env.meta.libPath))) : path.join(env.project.directory, 'node_modules'));
        let mResolvedPath;
        let m;
        debug(`Loading ${global ? 'global' : 'local'} plugin ${chalk_1.default.bold(pluginName)}`);
        try {
            mResolvedPath = require.resolve(path.resolve(modulesDir, pluginName));
            delete require.cache[mResolvedPath];
            m = require(mResolvedPath);
        }
        catch (e) {
            if (e.code !== 'MODULE_NOT_FOUND') {
                throw e;
            }
            debug(`${chalk_1.default.red(exports.ERROR_PLUGIN_NOT_INSTALLED)}: ${global ? 'global' : 'local'} ${chalk_1.default.bold(pluginName)}`);
            throw exports.ERROR_PLUGIN_NOT_INSTALLED;
        }
        if (m.version || !guards_1.isPlugin(m) || !mResolvedPath) {
            debug(`${chalk_1.default.red(exports.ERROR_PLUGIN_INVALID)}: ${global ? 'global' : 'local'} ${chalk_1.default.bold(pluginName)}`);
            throw exports.ERROR_PLUGIN_INVALID;
        }
        const meta = yield getPluginMeta(mResolvedPath);
        return Object.assign({}, m, { meta });
    });
}
exports.loadPlugin = loadPlugin;
function getPluginMeta(p) {
    return tslib_1.__awaiter(this, void 0, void 0, function* () {
        const pkg = yield npm_1.readPackageJsonFileOfResolvedModule(p);
        const distTag = determineDistTag(pkg.version);
        return {
            distTag,
            filePath: p,
            pkg,
        };
    });
}
exports.getPluginMeta = getPluginMeta;
