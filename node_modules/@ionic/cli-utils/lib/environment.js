"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const chalk_1 = require("chalk");
class Environment {
    constructor({ bottomBar, client, config, env, flags, getInfo, log, meta, namespace, plugins, project, prompt, session, shell, tasks, telemetry, }) {
        this.keepopen = false;
        this.bottomBar = bottomBar;
        this.client = client;
        this.config = config;
        this.env = env;
        this.flags = flags;
        this.getInfo = getInfo;
        this.log = log;
        this.meta = meta;
        this.namespace = namespace;
        this.plugins = plugins;
        this.project = project;
        this.prompt = prompt;
        this.session = session;
        this.shell = shell;
        this.tasks = tasks;
        this.telemetry = telemetry;
    }
    open() {
        if (this.flags.interactive) {
            if (!this.bottomBar) {
                const inquirer = require('inquirer');
                this.bottomBar = new inquirer.ui.BottomBar();
            }
            try {
                // the mute() call appears to be necessary, otherwise when answering
                // inquirer prompts upon pressing enter, a copy of the prompt is
                // printed to the screen and looks gross
                const bottomBarHack = this.bottomBar;
                bottomBarHack.rl.output.mute();
            }
            catch (e) {
                process.stderr.write(`EXCEPTION DURING BOTTOMBAR OUTPUT MUTE: ${e}\n`);
            }
        }
        this.log.outstream = typeof this.bottomBar === 'undefined' ? process.stdout : this.bottomBar.log;
        this.log.errstream = typeof this.bottomBar === 'undefined' ? process.stderr : this.bottomBar.log;
    }
    close() {
        if (!this.keepopen) {
            this.tasks.cleanup();
            // instantiating inquirer.ui.BottomBar hangs, so when close() is called,
            // we close BottomBar streams and replace the log stream with stdout.
            // This means inquirer shouldn't be used after command execution finishes
            // (which could happen during long-running processes like serve).
            if (this.bottomBar) {
                this.bottomBar.close();
                this.bottomBar = undefined;
                this.log.outstream = process.stdout;
                this.log.errstream = process.stderr;
            }
        }
    }
    runCommand(pargv, { showExecution = true } = {}) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            if (showExecution) {
                const metadata = yield this.namespace.getMetadata();
                this.log.rawmsg(`> ${chalk_1.default.green([metadata.name, ...pargv].map(a => a.includes(' ') ? `"${a}"` : a).join(' '))}`);
            }
            yield this.namespace.runCommand(pargv, this.env); // TODO
        });
    }
}
exports.Environment = Environment;
