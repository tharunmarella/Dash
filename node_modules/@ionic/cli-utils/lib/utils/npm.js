"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const path = require("path");
const chalk_1 = require("chalk");
const fs_1 = require("@ionic/cli-framework/utils/fs");
const npm_1 = require("@ionic/cli-framework/utils/npm");
/**
 * To be used with a module path resolved from require.resolve().
 */
function readPackageJsonFileOfResolvedModule(resolvedModule) {
    return tslib_1.__awaiter(this, void 0, void 0, function* () {
        const p = path.dirname(path.dirname(resolvedModule)); // "main": <folder>/index.js
        try {
            return yield npm_1.readPackageJsonFile(path.resolve(p, 'package.json'));
        }
        catch (e) {
            if (e !== fs_1.ERROR_FILE_NOT_FOUND) {
                throw e;
            }
            const p = path.dirname(resolvedModule); // "main": index.js
            return npm_1.readPackageJsonFile(path.resolve(p, 'package.json'));
        }
    });
}
exports.readPackageJsonFileOfResolvedModule = readPackageJsonFileOfResolvedModule;
/**
 * Resolves pkg manager intent with command args.
 *
 * TODO: this is a weird function and should be split up
 *
 * @return Promise<args> If the args is an empty array, it means the pkg manager doesn't have that command.
 */
function pkgManagerArgs({ npmClient = 'npm', shell }, options) {
    return tslib_1.__awaiter(this, void 0, void 0, function* () {
        let vocab;
        const cmd = options.command;
        if (cmd === 'dedupe') {
            delete options.pkg;
        }
        if (cmd === 'dedupe' || cmd === 'rebuild') {
            delete options.global;
            delete options.save;
            delete options.saveDev;
        }
        if (cmd === 'dedupe' || cmd === 'rebuild' || cmd === 'uninstall') {
            delete options.saveExact;
        }
        if (cmd === 'install' || cmd === 'uninstall') {
            if (options.global) {
                options.save = false;
                options.saveDev = false;
                options.saveExact = false;
            }
            else if (options.pkg && typeof options.save === 'undefined' && typeof options.saveDev === 'undefined') {
                options.save = true;
            }
            if (cmd === 'install' && options.pkg && typeof options.saveExact === 'undefined') {
                options.saveExact = true;
            }
        }
        const installerArgs = [];
        if (npmClient === 'npm') {
            vocab = { run: 'run', install: 'i', bareInstall: 'i', uninstall: 'uninstall', dedupe: 'dedupe', rebuild: 'rebuild', global: '-g', save: '--save', saveDev: '-D', saveExact: '-E', nonInteractive: '' };
        }
        else if (npmClient === 'yarn') {
            vocab = { run: 'run', install: 'add', bareInstall: 'install', uninstall: 'remove', dedupe: '', rebuild: 'install', global: '', save: '', saveDev: '--dev', saveExact: '--exact', nonInteractive: '--non-interactive' };
            if (options.global) {
                installerArgs.push('global');
            }
        }
        else {
            throw new Error(`unknown installer: ${npmClient}`);
        }
        if (cmd === 'install') {
            if (options.pkg) {
                installerArgs.push(vocab.install);
            }
            else {
                installerArgs.push(vocab.bareInstall);
            }
        }
        else if (cmd === 'uninstall') {
            installerArgs.push(vocab.uninstall);
        }
        else if (cmd === 'dedupe') {
            if (vocab.dedupe) {
                installerArgs.push(vocab.dedupe);
            }
            else {
                return [];
            }
        }
        else if (cmd === 'rebuild') {
            installerArgs.push(vocab.rebuild);
        }
        else {
            installerArgs.push(cmd);
        }
        if (options.global && vocab.global) {
            installerArgs.push(vocab.global);
        }
        if (options.save && vocab.save) {
            installerArgs.push(vocab.save);
        }
        if (options.saveDev && vocab.saveDev) {
            installerArgs.push(vocab.saveDev);
        }
        if (options.saveExact && vocab.saveExact) {
            installerArgs.push(vocab.saveExact);
        }
        if (vocab.nonInteractive) {
            installerArgs.push(vocab.nonInteractive);
        }
        if (options.pkg) {
            installerArgs.push(options.pkg);
        }
        if (cmd === 'run' && options.script) {
            installerArgs.push(options.script);
        }
        if (npmClient === 'yarn') {
            if (cmd === 'rebuild') {
                installerArgs.push('--force');
            }
        }
        if (cmd === 'run' && options.script && options.scriptArgs && options.scriptArgs.length > 0) {
            if (npmClient === 'npm') {
                installerArgs.push('--');
            }
            for (const arg of options.scriptArgs) {
                installerArgs.push(arg);
            }
        }
        return [npmClient, ...installerArgs];
    });
}
exports.pkgManagerArgs = pkgManagerArgs;
/**
 * TODO: switch this to use `package-json` module?
 *
 * @return Promise<latest version or `undefined`>
 */
function pkgLatestVersion(name, distTag = 'latest') {
    return tslib_1.__awaiter(this, void 0, void 0, function* () {
        const packageJson = yield Promise.resolve().then(() => require('package-json'));
        try {
            const pkg = yield packageJson(name, { version: distTag });
            const { version } = pkg; // TODO
            return typeof version === 'string' ? version : undefined;
        }
        catch (e) {
            // ignore
        }
    });
}
exports.pkgLatestVersion = pkgLatestVersion;
function promptToInstallPkg(env, options) {
    return tslib_1.__awaiter(this, void 0, void 0, function* () {
        const config = yield env.config.load();
        const { npmClient } = config;
        const [manager, ...managerArgs] = yield pkgManagerArgs({ npmClient, shell: env.shell }, Object.assign({ command: 'install' }, options));
        const confirm = yield env.prompt({
            name: 'confirm',
            message: `Install ${chalk_1.default.green(options.pkg)}?`,
            type: 'confirm',
        });
        if (!confirm) {
            env.log.warn(`Not installing--here's how to install it manually: ${chalk_1.default.green(`${manager} ${managerArgs.join(' ')}`)}`);
            return false;
        }
        yield env.shell.run(manager, managerArgs, { cwd: env.project.directory });
        return true;
    });
}
exports.promptToInstallPkg = promptToInstallPkg;
