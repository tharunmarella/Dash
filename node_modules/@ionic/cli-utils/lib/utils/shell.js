"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const os = require("os");
const path = require("path");
const split2 = require("split2");
const errors_1 = require("../errors");
const TILDE_PATH_REGEX = /^~($|\/|\\)/;
function expandTildePath(p) {
    const h = os.homedir();
    return p.replace(TILDE_PATH_REGEX, `${h}$1`);
}
exports.expandTildePath = expandTildePath;
function runcmd(command, args, options = {}) {
    return tslib_1.__awaiter(this, void 0, void 0, function* () {
        if (!options.env) {
            options.env = {};
        }
        const PATH = typeof options.env.PATH === 'string' ? options.env.PATH : process.env.PATH;
        options.env = Object.assign({}, process.env, options.env, { PATH: PATH.split(path.delimiter).map(expandTildePath).join(path.delimiter) });
        const p = yield spawncmd(command, args, options);
        return new Promise((resolve, reject) => {
            const stdoutBufs = [];
            const stderrBufs = [];
            const dualBufs = [];
            if (p.stdout) {
                if (options.stdoutPipe) {
                    p.stdout.pipe(split2()).pipe(options.stdoutPipe);
                }
                else {
                    p.stdout.on('data', chunk => {
                        if (Buffer.isBuffer(chunk)) {
                            stdoutBufs.push(chunk);
                            dualBufs.push(chunk);
                        }
                        else {
                            stdoutBufs.push(Buffer.from(chunk));
                            dualBufs.push(Buffer.from(chunk));
                        }
                    });
                }
            }
            if (p.stderr) {
                if (options.stderrPipe) {
                    p.stderr.pipe(split2()).pipe(options.stderrPipe);
                }
                else {
                    p.stderr.on('data', chunk => {
                        if (Buffer.isBuffer(chunk)) {
                            stderrBufs.push(chunk);
                            dualBufs.push(chunk);
                        }
                        else {
                            stderrBufs.push(Buffer.from(chunk));
                            dualBufs.push(Buffer.from(chunk));
                        }
                    });
                }
            }
            p.on('error', err => {
                reject(err);
            });
            p.on('close', code => {
                if (code === 0) {
                    resolve(Buffer.concat(stdoutBufs).toString());
                }
                else {
                    reject(new errors_1.ShellException(Buffer.concat(dualBufs).toString(), code));
                }
            });
        });
    });
}
exports.runcmd = runcmd;
function spawncmd(command, args, options = {}) {
    return tslib_1.__awaiter(this, void 0, void 0, function* () {
        const crossSpawn = yield Promise.resolve().then(() => require('cross-spawn'));
        const p = crossSpawn.spawn(command, args, options);
        return p;
    });
}
exports.spawncmd = spawncmd;
function forkcmd(command, args, options = {}) {
    return tslib_1.__awaiter(this, void 0, void 0, function* () {
        const cp = yield Promise.resolve().then(() => require('child_process'));
        const p = cp.fork(command, args, options);
        return p;
    });
}
exports.forkcmd = forkcmd;
function prettyCommand(command, args) {
    return command + ' ' + (args.length > 0 ? args.map(a => a.includes(' ') ? `"${a}"` : a).join(' ') : '');
}
exports.prettyCommand = prettyCommand;
