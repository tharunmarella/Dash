/// <reference types="node" />
import * as stream from 'stream';
import { Chalk } from 'chalk';
import { ILogger, LogLevel, LogPrefix, LoggerOptions } from '../../definitions';
export declare const LOGGER_STATUS_COLORS: Map<LogLevel, Chalk>;
export declare class Logger implements ILogger {
    readonly level: LogLevel;
    readonly prefix: LogPrefix;
    outstream: NodeJS.WritableStream;
    errstream: NodeJS.WritableStream;
    readonly wrap: boolean;
    constructor({level, prefix, outstream, errstream, wrap}: LoggerOptions);
    info(msg: string): void;
    ok(msg: string): void;
    warn(msg: string): void;
    error(msg: string): void;
    announce(msg: string): void;
    msg(msg: string): void;
    rawmsg(msg: string): void;
    nl(num?: number): void;
    clone(opts?: Partial<LoggerOptions>): Logger;
    createWriteStream(): {
        _write(chunk: any, encoding: string, callback: Function): void;
        writable: boolean;
        write(chunk: any, cb?: Function | undefined): boolean;
        write(chunk: any, encoding?: string | undefined, cb?: Function | undefined): boolean;
        setDefaultEncoding(encoding: string): any;
        end(cb?: Function | undefined): void;
        end(chunk: any, cb?: Function | undefined): void;
        end(chunk: any, encoding?: string | undefined, cb?: Function | undefined): void;
        addListener(event: string, listener: Function): any;
        addListener(event: "close", listener: () => void): any;
        addListener(event: "drain", listener: () => void): any;
        addListener(event: "error", listener: (err: Error) => void): any;
        addListener(event: "finish", listener: () => void): any;
        addListener(event: "pipe", listener: (src: stream.Readable) => void): any;
        addListener(event: "unpipe", listener: (src: stream.Readable) => void): any;
        emit(event: string | symbol, ...args: any[]): boolean;
        emit(event: "close"): boolean;
        emit(event: "drain", chunk: string | Buffer): boolean;
        emit(event: "error", err: Error): boolean;
        emit(event: "finish"): boolean;
        emit(event: "pipe", src: stream.Readable): boolean;
        emit(event: "unpipe", src: stream.Readable): boolean;
        on(event: string, listener: Function): any;
        on(event: "close", listener: () => void): any;
        on(event: "drain", listener: () => void): any;
        on(event: "error", listener: (err: Error) => void): any;
        on(event: "finish", listener: () => void): any;
        on(event: "pipe", listener: (src: stream.Readable) => void): any;
        on(event: "unpipe", listener: (src: stream.Readable) => void): any;
        once(event: string, listener: Function): any;
        once(event: "close", listener: () => void): any;
        once(event: "drain", listener: () => void): any;
        once(event: "error", listener: (err: Error) => void): any;
        once(event: "finish", listener: () => void): any;
        once(event: "pipe", listener: (src: stream.Readable) => void): any;
        once(event: "unpipe", listener: (src: stream.Readable) => void): any;
        prependListener(event: string, listener: Function): any;
        prependListener(event: "close", listener: () => void): any;
        prependListener(event: "drain", listener: () => void): any;
        prependListener(event: "error", listener: (err: Error) => void): any;
        prependListener(event: "finish", listener: () => void): any;
        prependListener(event: "pipe", listener: (src: stream.Readable) => void): any;
        prependListener(event: "unpipe", listener: (src: stream.Readable) => void): any;
        prependOnceListener(event: string, listener: Function): any;
        prependOnceListener(event: "close", listener: () => void): any;
        prependOnceListener(event: "drain", listener: () => void): any;
        prependOnceListener(event: "error", listener: (err: Error) => void): any;
        prependOnceListener(event: "finish", listener: () => void): any;
        prependOnceListener(event: "pipe", listener: (src: stream.Readable) => void): any;
        prependOnceListener(event: "unpipe", listener: (src: stream.Readable) => void): any;
        removeListener(event: string, listener: Function): any;
        removeListener(event: "close", listener: () => void): any;
        removeListener(event: "drain", listener: () => void): any;
        removeListener(event: "error", listener: (err: Error) => void): any;
        removeListener(event: "finish", listener: () => void): any;
        removeListener(event: "pipe", listener: (src: stream.Readable) => void): any;
        removeListener(event: "unpipe", listener: (src: stream.Readable) => void): any;
        pipe<T extends NodeJS.WritableStream>(destination: T, options?: {
            end?: boolean | undefined;
        } | undefined): T;
        removeAllListeners(event?: string | symbol | undefined): any;
        setMaxListeners(n: number): any;
        getMaxListeners(): number;
        listeners(event: string | symbol): Function[];
        eventNames(): (string | symbol)[];
        listenerCount(type: string | symbol): number;
    };
    shouldLog(level: LogLevel): boolean;
    private enforceLF(str);
    private getStatusColor(level);
    private _log(level, msg);
}
