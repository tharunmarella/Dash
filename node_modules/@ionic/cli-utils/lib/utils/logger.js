"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const util = require("util");
const stream = require("stream");
const chalk_1 = require("chalk");
const format_1 = require("@ionic/cli-framework/utils/format");
const guards_1 = require("../../guards");
const LOGGER_ERROR_LEVELS = ['warn', 'error', 'announce'];
exports.LOGGER_STATUS_COLORS = new Map([
    ['info', chalk_1.default.gray],
    ['ok', chalk_1.default.green],
    ['warn', chalk_1.default.yellow],
    ['error', chalk_1.default.red],
    ['announce', chalk_1.default.cyan],
]);
const LOGGER_STATUS_DEFINED_COLORS = new Map([
    ['info', chalk_1.default.bold],
    ['warn', chalk_1.default.bold.yellow],
    ['error', chalk_1.default.bold.red],
    ['announce', chalk_1.default.bold.cyan],
]);
class Logger {
    constructor({ level = 'info', prefix = '', outstream = process.stdout, errstream = process.stderr, wrap = true }) {
        this.level = level;
        this.prefix = prefix;
        this.outstream = outstream;
        this.errstream = errstream;
        this.wrap = wrap;
    }
    info(msg) {
        this._log('info', msg);
    }
    ok(msg) {
        this._log('ok', msg);
    }
    warn(msg) {
        this._log('warn', msg);
    }
    error(msg) {
        this._log('error', msg);
    }
    announce(msg) {
        this._log('announce', msg);
    }
    msg(msg) {
        this._log('msg', msg);
    }
    rawmsg(msg) {
        this.outstream.write(this.enforceLF(msg));
    }
    nl(num = 1) {
        this.outstream.write(this.enforceLF('\n'.repeat(num)));
    }
    clone(opts = {}) {
        const { level, prefix, outstream, errstream } = this;
        return new Logger(Object.assign({ level, prefix, outstream, errstream }, opts));
    }
    createWriteStream() {
        const self = this;
        return new class extends stream.Writable {
            _write(chunk, encoding, callback) {
                self.msg(chunk.toString());
                callback();
            }
        }();
    }
    shouldLog(level) {
        return guards_1.LOG_LEVELS.indexOf(level) >= guards_1.LOG_LEVELS.indexOf(this.level);
    }
    enforceLF(str) {
        return str.match(/[\r\n]$/) ? str : str + '\n';
    }
    getStatusColor(level) {
        const color = exports.LOGGER_STATUS_COLORS.get(level);
        if (!color) {
            return chalk_1.default.reset;
        }
        return color;
    }
    _log(level, msg) {
        if (this.shouldLog(level)) {
            let prefix = this.prefix;
            if (prefix) {
                if (typeof prefix === 'function') {
                    prefix = prefix();
                }
                msg = util.format(prefix, msg);
            }
            const color = this.getStatusColor(level);
            const status = color.bold.bgBlack;
            const b = chalk_1.default.dim;
            if (this.wrap) {
                const prefixIndentation = prefix ? format_1.stripAnsi(prefix).length + 1 : 0;
                const levelIndentation = level === 'msg' ? 0 : level.length + 3;
                const msgLines = format_1.wordWrap(msg, { indentation: prefixIndentation + levelIndentation }).split('\n');
                const definedColor = LOGGER_STATUS_DEFINED_COLORS.get(level);
                if (definedColor && msg.trim().includes('\n')) {
                    msg = msgLines.map((l, i) => {
                        // We want these log messages to stand out a bit, so automatically
                        // color the first line and separate the first line from the other
                        // lines if the message is multi-lined.
                        if (i === 0) {
                            return definedColor(l) + (msgLines.length > 1 ? '\n' : '');
                        }
                        return l;
                    }).join('\n') + '\n\n';
                }
                else {
                    msg = msgLines.join('\n');
                }
                msg = this.enforceLF(msg);
            }
            const fmtLevel = () => b('[') + status(level.toUpperCase()) + b(']');
            if (level !== 'msg') {
                msg = `${fmtLevel()} ${msg}`;
            }
            if (LOGGER_ERROR_LEVELS.includes(level)) {
                this.errstream.write(util.format(msg));
            }
            else {
                this.outstream.write(util.format(msg));
            }
        }
    }
}
exports.Logger = Logger;
