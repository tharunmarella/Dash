"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const chalk_1 = require("chalk");
const cli_framework_1 = require("@ionic/cli-framework");
const format_1 = require("@ionic/cli-framework/utils/format");
const constants_1 = require("../constants");
const guards_1 = require("../guards");
const HELP_DOTS_WIDTH = 25;
function showHelp(env, inputs) {
    return tslib_1.__awaiter(this, void 0, void 0, function* () {
        // If there are no inputs then show global command details.
        if (inputs.length === 0) {
            return env.log.rawmsg(yield formatNamespaceHelp(env, env.namespace, ''));
        }
        const location = yield env.namespace.locate(inputs);
        if (!guards_1.isCommand(location.obj) && location.args.length > 0) {
            env.log.error(`Unable to find command: ${chalk_1.default.green(inputs.join(' '))}` +
                (env.project.directory ? '' : '\nYou may need to be in an Ionic project directory.'));
        }
        const fullName = location.path.map(([p]) => p).join(' ');
        env.log.rawmsg(yield formatHelp(env, location, fullName));
    });
}
exports.showHelp = showHelp;
function formatHelp(env, location, fullName) {
    return tslib_1.__awaiter(this, void 0, void 0, function* () {
        // If the command is located on the global namespace then show its help
        if (!guards_1.isCommand(location.obj)) {
            return formatNamespaceHelp(env, location.obj, fullName);
        }
        const command = location.obj;
        return formatCommandHelp(env, yield command.getMetadata({ location }), fullName);
    });
}
function formatNamespaceHelp(env, ns, fullName) {
    return tslib_1.__awaiter(this, void 0, void 0, function* () {
        const cmdMetadataList = yield ns.getCommandMetadataList();
        const formatList = (details) => details.map(hd => `    ${hd}\n`).join('');
        const globalCmds = yield getCommandDetails(ns, cmdMetadataList.filter(cmd => cmd.type === 'global'));
        const projectCmds = yield getCommandDetails(ns, cmdMetadataList.filter(cmd => cmd.type === 'project'));
        return `${yield formatNamespaceHeader(env, ns, cmdMetadataList, fullName)}

  ${chalk_1.default.bold('Usage')}:

${yield formatUsage(env, ns)}
` + (globalCmds.length > 0 ? `  ${chalk_1.default.bold('Global Commands')}:\n\n${formatList(globalCmds)}\n` : '')
            + (projectCmds.length > 0 ? `  ${chalk_1.default.bold('Project Commands')}:\n\n${env.project.directory ? formatList(projectCmds) : '    You are not in a project directory.\n'}\n` : '');
    });
}
function formatNamespaceHeader(env, ns, cmdMetadataList, fullName) {
    return tslib_1.__awaiter(this, void 0, void 0, function* () {
        if (!ns.parent) {
            return formatHeader(env);
        }
        const metadata = yield ns.getMetadata();
        return `
  ${chalk_1.default.bold.green(fullName)} ${chalk_1.default.bold('-')} ${metadata.groups && metadata.groups.includes(constants_1.NamespaceGroup.Deprecated) ? chalk_1.default.yellow.bold('(deprecated)') + ' ' : ''}${chalk_1.default.bold(metadata.description)}${formatLongDescription(metadata.longDescription)}`;
    });
}
function formatHeader(env) {
    return tslib_1.__awaiter(this, void 0, void 0, function* () {
        const isLoggedIn = yield env.session.isLoggedIn();
        const now = new Date();
        const prefix = isLoggedIn ? chalk_1.default.blue('PRO') + ' ' : '';
        const version = env.plugins.ionic.meta.pkg.version;
        const suffix = now.getMonth() === 9 && now.getDate() === 31 ? ' ðŸŽƒ' : '';
        return `   _             _
  (_) ___  _ __ (_) ___
  | |/ _ \\| '_ \\| |/ __|
  | | (_) | | | | | (__
  |_|\\___/|_| |_|_|\\___|  CLI ${prefix}${version}${suffix}\n`;
    });
}
function formatUsage(env, ns) {
    return tslib_1.__awaiter(this, void 0, void 0, function* () {
        const metadata = yield ns.getMetadata();
        let name = metadata.name;
        if (ns.parent) {
            name = `ionic ${name}`; // TODO: recurse back ns chain
        }
        const options = ['--help', '--verbose', '--quiet', '--no-interactive', '--no-color', '--confirm'];
        const usageLines = [
            `<command> ${chalk_1.default.dim('[<args>]')} ${options.map(opt => chalk_1.default.dim('[' + opt + ']')).join(' ')} ${chalk_1.default.dim('[options]')}`,
        ];
        return usageLines.map(u => `    ${chalk_1.default.dim('$')} ${chalk_1.default.green(name + ' ' + u)}`).join('\n') + '\n';
    });
}
function getCommandDetails(ns, commands) {
    return tslib_1.__awaiter(this, void 0, void 0, function* () {
        commands = commands.filter(cmd => !cmd.groups || !cmd.groups.includes(constants_1.CommandGroup.Hidden));
        const [cmdDetails, nsDetails] = yield Promise.all([
            getListOfCommandDetails(commands.filter(cmd => cmd.namespace === ns)),
            getListOfNamespaceDetails(commands.filter(cmd => cmd.namespace !== ns)),
        ]);
        const details = [...cmdDetails, ...nsDetails];
        details.sort();
        return details;
    });
}
function formatCommandHelp(env, metadata, fullName) {
    return tslib_1.__awaiter(this, void 0, void 0, function* () {
        const isHidden = metadata.groups && metadata.groups.includes(constants_1.CommandGroup.Hidden);
        if (isHidden) {
            env.log.warn(`${chalk_1.default.green(fullName)} is a hidden command. These docs may not be helpful.`);
        }
        return formatCommandHeader(metadata, fullName) +
            (yield formatCommandUsage(env, metadata, fullName)) +
            (yield formatCommandInputs(metadata.inputs)) +
            (yield formatCommandOptions(metadata.options)) +
            (yield formatCommandExamples(metadata.exampleCommands, fullName));
    });
}
function formatCommandHeader(metadata, fullName) {
    const wrappedDescription = format_1.wordWrap(metadata.description, { indentation: fullName.length + 5 });
    const isDeprecated = metadata.groups && metadata.groups.includes(constants_1.CommandGroup.Deprecated);
    const subtitle = (isDeprecated ? chalk_1.default.yellow('(deprecated)') + ' ' : '') + wrappedDescription;
    return `\n  ${chalk_1.default.bold(chalk_1.default.green(fullName) + (subtitle ? ` - ${subtitle}` : ''))}${formatLongDescription(metadata.longDescription)}\n`;
}
function getListOfCommandDetails(commands) {
    return tslib_1.__awaiter(this, void 0, void 0, function* () {
        const wow = commands.map(cmd => cmd.path.map(([p]) => p).join(' '));
        const fillStringArray = format_1.generateFillSpaceStringList(wow, HELP_DOTS_WIDTH, chalk_1.default.dim('.'));
        return commands.map((cmd, index) => {
            const isDeprecated = cmd.groups && cmd.groups.includes(constants_1.CommandGroup.Deprecated);
            const description = (isDeprecated ? chalk_1.default.yellow.bold('(deprecated)') + ' ' : '') + cmd.description + `${cmd.aliases.length > 0 ? chalk_1.default.dim(' (alias' + (cmd.aliases.length === 1 ? '' : 'es') + ': ') + cmd.aliases.map(a => chalk_1.default.green(a)).join(', ') + chalk_1.default.dim(')') : ''}`;
            const wrappedDescription = format_1.wordWrap(description, { indentation: HELP_DOTS_WIDTH + 6 });
            return `${chalk_1.default.green(cmd.path.map(p => p[0]).join(' '))} ${fillStringArray[index]} ${wrappedDescription}`;
        });
    });
}
function getListOfNamespaceDetails(commands) {
    return tslib_1.__awaiter(this, void 0, void 0, function* () {
        const descriptions = new Map();
        const grouped = new Map();
        yield Promise.all(commands.map((cmd) => tslib_1.__awaiter(this, void 0, void 0, function* () {
            if (!cmd.groups || !cmd.groups.includes(constants_1.CommandGroup.Hidden)) {
                const nsmeta = yield cmd.namespace.getMetadata();
                descriptions.set(nsmeta.name, nsmeta.description);
                let entry = grouped.get(nsmeta.name);
                if (!entry) {
                    entry = { meta: nsmeta, cmds: [] };
                    grouped.set(nsmeta.name, entry);
                }
                entry.cmds.push(cmd);
            }
        })));
        const entries = [...grouped.entries()];
        const fillStringArray = format_1.generateFillSpaceStringList(entries.map(([name]) => name + ' <subcommand>'), HELP_DOTS_WIDTH, chalk_1.default.dim('.'));
        return entries.map(([name, { meta, cmds }], i) => {
            const subcommands = cmds.map(c => chalk_1.default.green(c.name)).join(', ');
            const isDeprecated = meta.groups && meta.groups.includes(constants_1.NamespaceGroup.Deprecated);
            const wrappedDescription = format_1.wordWrap(`${isDeprecated ? chalk_1.default.yellow.bold('(deprecated)') + ' ' : ''}${descriptions.get(name)} ${chalk_1.default.dim('(subcommands:')} ${subcommands}${chalk_1.default.dim(')')}`, { indentation: HELP_DOTS_WIDTH + 6 });
            return `${chalk_1.default.green(name + ' <subcommand>')} ${fillStringArray[i]} ${wrappedDescription}`;
        });
    });
}
function formatCommandUsage(env, metadata, fullName) {
    return tslib_1.__awaiter(this, void 0, void 0, function* () {
        const formatInput = (input) => {
            if (!env.flags.interactive && input.validators && input.validators.includes(cli_framework_1.validators.required)) {
                return '<' + input.name + '>';
            }
            return '[<' + input.name + '>]';
        };
        const options = yield filterOptionsForHelp(metadata.options);
        const usageLine = `${chalk_1.default.dim('$')} ${chalk_1.default.green(fullName + (typeof metadata.inputs === 'undefined' ? '' : ' ' + metadata.inputs.map(formatInput).join(' ')))} ${options.length > 0 ? chalk_1.default.green('[options]') : ''}`;
        return `
  ${chalk_1.default.bold('Usage')}:

    ${usageLine}
  `;
    });
}
function formatLongDescription(longDescription) {
    if (!longDescription) {
        return '';
    }
    longDescription = longDescription.trim();
    longDescription = format_1.wordWrap(longDescription, { indentation: 4 });
    return '\n\n    ' + longDescription;
}
function formatCommandInputs(inputs = []) {
    return tslib_1.__awaiter(this, void 0, void 0, function* () {
        if (inputs.length === 0) {
            return '';
        }
        const fillStrings = format_1.generateFillSpaceStringList(inputs.map(input => input.name), HELP_DOTS_WIDTH, chalk_1.default.dim('.'));
        function inputLineFn({ name, description }, index) {
            const optionList = chalk_1.default.green(`${name}`);
            const wrappedDescription = format_1.wordWrap(description, { indentation: HELP_DOTS_WIDTH + 6 });
            return `${optionList} ${fillStrings[index]} ${wrappedDescription}`;
        }
        return `
  ${chalk_1.default.bold('Inputs')}:

    ${inputs.map(inputLineFn).join(`
    `)}
  `;
    });
}
function formatOptionDefault(opt) {
    if (typeof opt.default === 'string') {
        return chalk_1.default.dim(' (default: ') + chalk_1.default.green(opt.default) + chalk_1.default.dim(')');
    }
    else {
        return '';
    }
}
function formatOptionLine(opt) {
    const showInverse = opt.type === Boolean && opt.default === true && opt.name.length > 1;
    const optionList = (showInverse ? chalk_1.default.green(`--no-${opt.name}`) : chalk_1.default.green(`-${opt.name.length > 1 ? '-' : ''}${opt.name}`)) +
        (!showInverse && opt.aliases && opt.aliases.length > 0 ? ', ' +
            opt.aliases
                .map(alias => chalk_1.default.green(`-${alias}`))
                .join(', ') : '');
    const optionListLength = format_1.stringWidth(optionList);
    const fullLength = optionListLength > HELP_DOTS_WIDTH ? optionListLength + 1 : HELP_DOTS_WIDTH;
    const wrappedDescription = format_1.wordWrap((opt.hint ? `${chalk_1.default.dim(`[${opt.hint}]`)} ` : '') + opt.description + formatOptionDefault(opt), { indentation: HELP_DOTS_WIDTH + 6 });
    return `${optionList} ${Array(fullLength - optionListLength).fill(chalk_1.default.dim('.')).join('')} ${wrappedDescription}`;
}
function filterOptionsForHelp(options = []) {
    return tslib_1.__awaiter(this, void 0, void 0, function* () {
        return options.filter(opt => !opt.groups || !opt.groups.includes(constants_1.OptionGroup.Hidden));
    });
}
function formatCommandOptions(options = []) {
    return tslib_1.__awaiter(this, void 0, void 0, function* () {
        options = yield filterOptionsForHelp(options);
        if (options.length === 0) {
            return '';
        }
        const basicOptions = options.filter(o => !o.groups || !o.groups.includes(constants_1.OptionGroup.Advanced));
        const advancedOptions = options.filter(o => o.groups && o.groups.includes(constants_1.OptionGroup.Advanced));
        const basicOptionsOutput = basicOptions.length > 0 ? `
  ${chalk_1.default.bold('Options')}:

    ${basicOptions.map(formatOptionLine).join(`
    `)}
  ` : '';
        const advancedOptionsOutput = advancedOptions.length > 0 ? `
  ${chalk_1.default.bold('Advanced Options')}:

    ${advancedOptions.map(formatOptionLine).join(`
    `)}
  ` : '';
        return basicOptionsOutput + advancedOptionsOutput;
    });
}
function formatCommandExamples(exampleCommands, fullName) {
    return tslib_1.__awaiter(this, void 0, void 0, function* () {
        if (!Array.isArray(exampleCommands)) {
            return '';
        }
        const exampleLines = exampleCommands.map(cmd => {
            const sepIndex = cmd.indexOf(' -- ');
            cmd = sepIndex === -1 ? chalk_1.default.green(cmd) : chalk_1.default.green(cmd.substring(0, sepIndex)) + cmd.substring(sepIndex);
            const wrappedCmd = format_1.wordWrap(cmd, { indentation: 12, append: ' \\' });
            return `${chalk_1.default.dim('$')} ${chalk_1.default.green(fullName)} ${wrappedCmd}`;
        });
        return `
  ${chalk_1.default.bold('Examples')}:

    ${exampleLines.join(`
    `)}
  `;
    });
}
