"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const os = require("os");
const path = require("path");
const chalk_1 = require("chalk");
const Debug = require("debug");
const through2 = require("through2");
const split2 = require("split2");
const string_1 = require("@ionic/cli-framework/utils/string");
const fs_1 = require("@ionic/cli-framework/utils/fs");
const guards_1 = require("../guards");
const constants_1 = require("../constants");
const errors_1 = require("./errors");
const project_1 = require("./project");
const runner_1 = require("./runner");
const hooks_1 = require("./hooks");
const debug = Debug('ionic:cli-utils:lib:serve');
exports.DEFAULT_DEV_LOGGER_PORT = 53703;
exports.DEFAULT_LIVERELOAD_PORT = 35729;
exports.DEFAULT_SERVER_PORT = 8100;
exports.DEFAULT_LAB_PORT = 8200;
exports.BIND_ALL_ADDRESS = '0.0.0.0';
exports.LOCAL_ADDRESSES = ['localhost', '127.0.0.1'];
exports.BROWSERS = ['safari', 'firefox', process.platform === 'win32' ? 'chrome' : (process.platform === 'darwin' ? 'google chrome' : 'google-chrome')];
// npm script name
exports.SERVE_SCRIPT = 'ionic:serve';
exports.COMMON_SERVE_COMMAND_OPTIONS = [
    {
        name: 'address',
        description: 'Use specific address for the dev server',
        default: exports.BIND_ALL_ADDRESS,
        groups: [constants_1.OptionGroup.Advanced],
    },
    {
        name: 'port',
        description: 'Use specific port for HTTP',
        default: exports.DEFAULT_SERVER_PORT.toString(),
        aliases: ['p'],
        groups: [constants_1.OptionGroup.Advanced],
    },
    {
        name: 'livereload',
        description: 'Do not spin up dev server--just serve files',
        type: Boolean,
        default: true,
    },
    {
        name: 'proxy',
        description: 'Do not add proxies',
        type: Boolean,
        default: true,
        groups: [constants_1.OptionGroup.Advanced],
    },
];
class ServeRunner extends runner_1.Runner {
    constructor(env) {
        super();
        this.env = env;
    }
    static createFromProjectType(env, type) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            if (type === 'ionic1') {
                const { ServeRunner } = yield Promise.resolve().then(() => require('./project/ionic1/serve'));
                return new ServeRunner(env);
            }
            else if (type === 'ionic-angular') {
                const { ServeRunner } = yield Promise.resolve().then(() => require('./project/ionic-angular/serve'));
                return new ServeRunner(env);
            }
            else if (type === 'angular') {
                const { ServeRunner } = yield Promise.resolve().then(() => require('./project/angular/serve'));
                return new ServeRunner(env);
            }
            else {
                throw new errors_1.RunnerNotFoundException(`Cannot perform serve for ${type ? '' : 'unknown '}project type${type ? `: ${chalk_1.default.bold(type)}` : ''}.\n` +
                    (type === 'custom' ? `Since you're using the ${chalk_1.default.bold('custom')} project type, this command won't work. The Ionic CLI doesn't know how to serve custom projects.\n\n` : '') +
                    `If you'd like the CLI to try to detect your project type, you can unset the ${chalk_1.default.bold('type')} attribute in ${chalk_1.default.bold(project_1.PROJECT_FILE)}.`);
            }
        });
    }
    createOptionsFromCommandLine(inputs, options) {
        const separatedArgs = options['--'];
        if (options['local']) {
            options['address'] = 'localhost';
            options['devapp'] = false;
        }
        const engine = options['engine'] ? String(options['engine']) : 'browser';
        const address = options['address'] ? String(options['address']) : exports.BIND_ALL_ADDRESS;
        const labPort = string_1.str2num(options['lab-port'], exports.DEFAULT_LAB_PORT);
        const port = string_1.str2num(options['port'], exports.DEFAULT_SERVER_PORT);
        return {
            '--': separatedArgs ? separatedArgs : [],
            address,
            browser: options['browser'] ? String(options['browser']) : undefined,
            browserOption: options['browseroption'] ? String(options['browseroption']) : undefined,
            devapp: engine === 'browser' && (typeof options['devapp'] === 'undefined' || options['devapp']) ? true : false,
            engine,
            externalAddressRequired: options['externalAddressRequired'] ? true : false,
            lab: options['lab'] ? true : false,
            labHost: options['lab-host'] ? String(options['lab-host']) : 'localhost',
            labPort,
            livereload: typeof options['livereload'] === 'boolean' ? Boolean(options['livereload']) : true,
            open: options['open'] ? true : false,
            port,
            platform: options['platform'] ? String(options['platform']) : undefined,
            proxy: typeof options['proxy'] === 'boolean' ? Boolean(options['proxy']) : true,
        };
    }
    checkDevApp(options) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            const pkg = yield this.env.project.loadPackageJson();
            // If this is regular `ionic serve`, we warn the dev about unsupported
            // plugins in the devapp.
            if (options.devapp && guards_1.isCordovaPackageJson(pkg)) {
                const plugins = yield this.getSupportedDevAppPlugins();
                const packageCordovaPlugins = Object.keys(pkg.cordova.plugins);
                const packageCordovaPluginsDiff = packageCordovaPlugins.filter(p => !plugins.has(p));
                if (packageCordovaPluginsDiff.length > 0) {
                    this.env.log.warn('Detected unsupported Cordova plugins with Ionic DevApp:\n' +
                        `${packageCordovaPluginsDiff.map(p => `- ${chalk_1.default.bold(p)}`).join('\n')}\n\n` +
                        `App may not function as expected in Ionic DevApp and Ionic View.`);
                }
            }
        });
    }
    run(options) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            const { promptToInstallPkg } = yield Promise.resolve().then(() => require('./utils/npm'));
            const { findClosestOpenPort } = yield Promise.resolve().then(() => require('./utils/network'));
            const before = new ServeBeforeHook(this.env);
            try {
                yield before.run({ name: before.name, serve: options });
            }
            catch (e) {
                if (e instanceof errors_1.Exception) {
                    throw new errors_1.FatalException(e.message);
                }
                throw e;
            }
            yield this.checkDevApp(options);
            const devAppDetails = yield this.gatherDevAppDetails(options);
            const details = yield this.serveProject(options);
            let labDetails;
            if (options.lab) {
                labDetails = {
                    protocol: 'http',
                    address: options.labHost,
                    port: yield findClosestOpenPort(options.labPort, '0.0.0.0'),
                };
                try {
                    yield this.runLab(`http://localhost:${details.port}`, labDetails);
                }
                catch (e) {
                    if (e.code === 'ENOENT') {
                        const pkg = '@ionic/lab';
                        this.env.log.nl();
                        this.env.log.warn(`Looks like ${chalk_1.default.green(pkg)} isn't installed in this project.\n` +
                            `This package is required for Ionic Lab as of CLI 4.0. For more details, please see the CHANGELOG: ${chalk_1.default.bold('https://github.com/ionic-team/ionic-cli/blob/master/CHANGELOG.md#4.0.0')}`);
                        const installed = yield promptToInstallPkg(this.env, { pkg, saveDev: true });
                        if (!installed) {
                            throw new errors_1.FatalException(`${chalk_1.default.green(pkg)} is required for Ionic Lab to work properly.`);
                        }
                        yield this.runLab(`http://localhost:${details.port}`, labDetails);
                    }
                }
            }
            if (devAppDetails) {
                const devAppName = yield this.publishDevApp(options, Object.assign({ port: details.port }, devAppDetails));
                devAppDetails.channel = devAppName;
            }
            const localAddress = `${details.protocol}://localhost:${details.port}`;
            const fmtExternalAddress = (address) => `${details.protocol}://${address}:${details.port}`;
            const labAddress = labDetails ? `${labDetails.protocol}://${labDetails.address}:${labDetails.port}` : undefined;
            this.env.log.nl();
            this.env.log.ok(`Development server running!\n` +
                (labAddress ? `Lab: ${chalk_1.default.bold(labAddress)}\n` : '') +
                `Local: ${chalk_1.default.bold(localAddress)}\n` +
                (details.externalNetworkInterfaces.length > 0 ? `External: ${details.externalNetworkInterfaces.map(v => chalk_1.default.bold(fmtExternalAddress(v.address))).join(', ')}\n` : '') +
                (devAppDetails && devAppDetails.channel ? `DevApp: ${chalk_1.default.bold(devAppDetails.channel)} on ${chalk_1.default.bold(os.hostname())}` : ''));
            this.env.log.nl();
            if (options.open) {
                const openAddress = labAddress ? labAddress : localAddress;
                const openURL = [openAddress]
                    .concat(options.browserOption ? [options.browserOption] : [])
                    .concat(options.platform ? ['?ionicplatform=', options.platform] : [])
                    .join('');
                const opn = yield Promise.resolve().then(() => require('opn'));
                opn(openURL, { app: options.browser, wait: false });
                this.env.log.info(`Browser window opened to ${chalk_1.default.bold(openURL)}!`);
                this.env.log.nl();
            }
            this.env.keepopen = true;
            return details;
        });
    }
    gatherDevAppDetails(options) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            if (options.devapp) {
                const { getSuitableNetworkInterfaces } = yield Promise.resolve().then(() => require('./utils/network'));
                const { computeBroadcastAddress } = yield Promise.resolve().then(() => require('./devapp'));
                const availableInterfaces = getSuitableNetworkInterfaces();
                // TODO: There is no accurate/reliable/realistic way to identify a WiFi
                // network uniquely in NodeJS. But this is where we could detect new
                // networks and prompt the dev if they want to "trust" it (allow binding to
                // 0.0.0.0 and broadcasting).
                const interfaces = availableInterfaces
                    .map(i => (Object.assign({}, i, { broadcast: computeBroadcastAddress(i.address, i.netmask) })));
                return { interfaces };
            }
        });
    }
    publishDevApp(options, details) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            if (options.devapp) {
                const { createPublisher } = yield Promise.resolve().then(() => require('./devapp'));
                const publisher = yield createPublisher(this.env, details.port);
                publisher.interfaces = details.interfaces;
                publisher.on('error', (err) => {
                    debug(`Error in DevApp service: ${String(err.stack ? err.stack : err)}`);
                });
                try {
                    yield publisher.start();
                }
                catch (e) {
                    this.env.log.error(`Could not publish DevApp service: ${String(e.stack ? e.stack : e)}`);
                }
                return publisher.name;
            }
        });
    }
    getSupportedDevAppPlugins() {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            const p = path.resolve(__dirname, '..', 'assets', 'devapp', 'plugins.json');
            const plugins = yield fs_1.fsReadJsonFile(p);
            if (!Array.isArray(plugins)) {
                throw new Error(`Cannot read ${p} file of supported plugins.`);
            }
            // This one is common, and hopefully obvious enough that the devapp doesn't
            // use any splash screen but its own, so we mark it as "supported".
            plugins.push('cordova-plugin-splashscreen');
            return new Set(plugins);
        });
    }
    runLab(url, details) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            const { registerShutdownFunction } = yield Promise.resolve().then(() => require('./process'));
            const project = yield this.env.project.load();
            const pkg = yield this.env.project.loadPackageJson();
            const labArgs = [url, '--host', details.address, '--port', String(details.port)];
            const nameArgs = project.name ? ['--app-name', project.name] : [];
            const versionArgs = pkg.version ? ['--app-version', pkg.version] : [];
            const p = yield this.env.shell.spawn('ionic-lab', [...labArgs, ...nameArgs, ...versionArgs], { cwd: this.env.project.directory, env: Object.assign({ FORCE_COLOR: chalk_1.default.enabled ? '1' : '0' }, process.env) });
            return new Promise((resolve, reject) => {
                p.on('error', err => {
                    reject(err);
                });
                registerShutdownFunction(() => p.kill());
                const log = this.env.log.clone({ prefix: chalk_1.default.dim('[lab]'), wrap: false });
                const ws = log.createWriteStream();
                const stdoutFilter = through2(function (chunk, enc, callback) {
                    const str = chunk.toString();
                    if (str.includes('Ionic Lab running')) {
                        resolve();
                    }
                    else {
                        // no stdout
                    }
                    callback();
                });
                p.stdout.pipe(split2()).pipe(stdoutFilter).pipe(ws);
                p.stderr.pipe(split2()).pipe(ws);
            });
        });
    }
    selectExternalIP(options) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            const { getSuitableNetworkInterfaces } = yield Promise.resolve().then(() => require('./utils/network'));
            let availableInterfaces = [];
            let chosenIP = options.address;
            if (options.address === exports.BIND_ALL_ADDRESS) {
                availableInterfaces = getSuitableNetworkInterfaces();
                if (availableInterfaces.length === 0) {
                    if (options.externalAddressRequired) {
                        throw new errors_1.FatalException(`No external network interfaces detected. In order to use livereload with run/emulate you will need one.\n` +
                            `Are you connected to a local network?\n`);
                    }
                }
                else if (availableInterfaces.length === 1) {
                    chosenIP = availableInterfaces[0].address;
                }
                else if (availableInterfaces.length > 1) {
                    if (options.externalAddressRequired) {
                        this.env.log.warn('Multiple network interfaces detected!\n' +
                            'You will be prompted to select an external-facing IP for the livereload server that your device or emulator has access to.\n\n' +
                            `You may also use the ${chalk_1.default.green('--address')} option to skip this prompt.`);
                        const promptedIp = yield this.env.prompt({
                            type: 'list',
                            name: 'promptedIp',
                            message: 'Please select which IP to use:',
                            choices: availableInterfaces.map(i => ({
                                name: `${i.address} ${chalk_1.default.dim(`(${i.deviceName})`)}`,
                                value: i.address,
                            })),
                        });
                        chosenIP = promptedIp;
                    }
                }
            }
            return [chosenIP, availableInterfaces];
        });
    }
}
exports.ServeRunner = ServeRunner;
class ServeBeforeHook extends hooks_1.Hook {
    constructor() {
        super(...arguments);
        this.name = 'serve:before';
    }
}
function serve(env, inputs, options) {
    return tslib_1.__awaiter(this, void 0, void 0, function* () {
        try {
            const runner = yield ServeRunner.createFromProjectType(env, env.project.type);
            const opts = runner.createOptionsFromCommandLine(inputs, options);
            const details = yield runner.run(opts);
            return details;
        }
        catch (e) {
            if (e instanceof errors_1.RunnerException) {
                throw new errors_1.FatalException(e.message);
            }
            throw e;
        }
    });
}
exports.serve = serve;
