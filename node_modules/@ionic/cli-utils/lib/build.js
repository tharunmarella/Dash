"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const chalk_1 = require("chalk");
const errors_1 = require("./errors");
const project_1 = require("./project");
const runner_1 = require("./runner");
const hooks_1 = require("./hooks");
exports.BUILD_SCRIPT = 'ionic:build';
class BuildRunner extends runner_1.Runner {
    constructor(env) {
        super();
        this.env = env;
    }
    static createFromProjectType(env, type) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            if (type === 'angular') {
                const { BuildRunner } = yield Promise.resolve().then(() => require('./project/angular/build'));
                return new BuildRunner(env);
            }
            else if (type === 'ionic-angular') {
                const { BuildRunner } = yield Promise.resolve().then(() => require('./project/ionic-angular/build'));
                return new BuildRunner(env);
            }
            else if (type === 'ionic1') {
                const { BuildRunner } = yield Promise.resolve().then(() => require('./project/ionic1/build'));
                return new BuildRunner(env);
            }
            else {
                throw new errors_1.RunnerNotFoundException(`Cannot perform build for ${type ? '' : 'unknown '}project type${type ? `: ${chalk_1.default.bold(type)}` : ''}.\n` +
                    (type === 'custom' ? `Since you're using the ${chalk_1.default.bold('custom')} project type, this command won't work. The Ionic CLI doesn't know how to build custom projects.\n\n` : '') +
                    `If you'd like the CLI to try to detect your project type, you can unset the ${chalk_1.default.bold('type')} attribute in ${chalk_1.default.bold(project_1.PROJECT_FILE)}.`);
            }
        });
    }
    createBaseOptionsFromCommandLine(inputs, options) {
        const separatedArgs = options['--'];
        const platform = options['platform'] ? String(options['platform']) : undefined;
        const engine = options['engine'] ? String(options['engine']) : 'browser';
        return { '--': separatedArgs ? separatedArgs : [], engine, platform };
    }
    run(options) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            const before = new BuildBeforeHook(this.env);
            try {
                yield before.run({ name: before.name, build: options });
            }
            catch (e) {
                if (e instanceof errors_1.Exception) {
                    throw new errors_1.FatalException(e.message);
                }
                throw e;
            }
            yield this.buildProject(options);
            const after = new BuildAfterHook(this.env);
            try {
                yield after.run({ name: after.name, build: options });
            }
            catch (e) {
                if (e instanceof errors_1.Exception) {
                    throw new errors_1.FatalException(e.message);
                }
                throw e;
            }
        });
    }
}
exports.BuildRunner = BuildRunner;
class BuildBeforeHook extends hooks_1.Hook {
    constructor() {
        super(...arguments);
        this.name = 'build:before';
    }
}
class BuildAfterHook extends hooks_1.Hook {
    constructor() {
        super(...arguments);
        this.name = 'build:after';
    }
}
function build(env, inputs, options) {
    return tslib_1.__awaiter(this, void 0, void 0, function* () {
        try {
            const runner = yield BuildRunner.createFromProjectType(env, env.project.type);
            const opts = runner.createOptionsFromCommandLine(inputs, options);
            yield runner.run(opts);
        }
        catch (e) {
            if (e instanceof errors_1.RunnerException) {
                throw new errors_1.FatalException(e.message);
            }
            throw e;
        }
    });
}
exports.build = build;
