"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const chalk_1 = require("chalk");
const Debug = require("debug");
const guards_1 = require("../../guards");
const ailments_1 = require("./ailments");
tslib_1.__exportStar(require("./ailments"), exports);
const debug = Debug('ionic:cli-utils:lib:doctor');
function treatAilments(env) {
    return tslib_1.__awaiter(this, void 0, void 0, function* () {
        const registry = yield env.project.getAilmentRegistry(env);
        const config = yield env.config.load();
        let count = 0;
        const isLoggedIn = yield env.session.isLoggedIn();
        if (!isLoggedIn) {
            env.log.warn(`For best results, please make sure you're logged in to Ionic.\nSome issues can't be detected without authentication. Run:\n\n    ${chalk_1.default.green('ionic login')}`);
        }
        env.tasks.next('Detecting issues');
        const ailments = yield Promise.all(registry.ailments.map((ailment) => tslib_1.__awaiter(this, void 0, void 0, function* () {
            let detected = false;
            try {
                debug(`Detecting ${chalk_1.default.bold(ailment.id)}`);
                detected = yield ailment.detected();
            }
            catch (e) {
                env.log.error(`Error while checking ${chalk_1.default.bold(ailment.id)}:\n\n${chalk_1.default.red(e.stack ? e.stack : e)}`);
            }
            count++;
            env.tasks.updateMsg(`Detecting issues: ${chalk_1.default.bold(`${count} / ${registry.ailments.length}`)} complete`);
            return [ailment, detected];
        })));
        env.tasks.updateMsg(`Detecting issues: ${chalk_1.default.bold(`${registry.ailments.length} / ${registry.ailments.length}`)} complete`);
        const detectedAilments = ailments
            .filter(([, detected]) => detected)
            .map(([ailment]) => ailment)
            .filter(ailment => !config.state.doctor.ignored.includes(ailment.id));
        let treatedAilmentCount = 0;
        let manuallyTreatableAilmentCount = 0;
        env.tasks.end();
        const fn = detectedAilments.length > 0 ? env.log.info.bind(env.log) : env.log.ok.bind(env.log);
        fn(`Detected ${chalk_1.default.bold(String(detectedAilments.length))} issue${detectedAilments.length === 1 ? '' : 's'}.${detectedAilments.length === 0 ? ' Aww yeah! ðŸ’ª' : ''}`);
        if (detectedAilments.length > 0) {
            for (const ailment of detectedAilments) {
                const treated = yield treatAilment(env, ailment);
                if (guards_1.isAutomaticallyTreatableAilment(ailment)) {
                    if (treated) {
                        treatedAilmentCount++;
                    }
                }
                else {
                    manuallyTreatableAilmentCount++;
                }
            }
            if (treatedAilmentCount > 0) {
                const fn = manuallyTreatableAilmentCount > 0 ? env.log.info.bind(env.log) : env.log.ok.bind(env.log);
                fn(`Fixed ${treatedAilmentCount} issue${treatedAilmentCount === 1 ? '' : 's'}!`);
            }
            if (manuallyTreatableAilmentCount > 0) {
                env.log.msg(`${manuallyTreatableAilmentCount} ${manuallyTreatableAilmentCount === 1 ? 'issue needs' : 'issues need'} to be fixed manually.`);
            }
        }
    });
}
exports.treatAilments = treatAilments;
function detectAndTreatAilment(env, ailment) {
    return tslib_1.__awaiter(this, void 0, void 0, function* () {
        const detected = yield ailment.detected();
        if (detected) {
            yield treatAilment(env, ailment);
        }
        else {
            env.log.ok(`All good! ${chalk_1.default.green(ailment.id)} not detected.`);
        }
    });
}
exports.detectAndTreatAilment = detectAndTreatAilment;
function treatAilment(env, ailment) {
    return tslib_1.__awaiter(this, void 0, void 0, function* () {
        if (guards_1.isAutomaticallyTreatableAilment(ailment)) {
            try {
                const treated = yield ailment.treat();
                return treated;
            }
            catch (e) {
                if (e !== ailments_1.ERROR_AILMENT_SKIPPED && e !== ailments_1.ERROR_AILMENT_IGNORED) {
                    if (guards_1.isExitCodeException(e)) {
                        env.log.error(`Error occurred during automatic fix: ${e.message}`);
                    }
                    else {
                        env.log.error(`Error occurred during automatic fix: ${e.stack ? e.stack : e}`);
                    }
                }
            }
        }
        else {
            const treatmentSteps = yield ailment.getTreatmentSteps();
            const stepOutput = treatmentSteps.length > 0 ? `\n\nTo fix, take the following step(s):\n\n${treatmentSteps.map((step, i) => `    ${i + 1}) ${step.name}`).join('\n')}` : '';
            env.log.warn(`${yield ailment.getMessage()} ${stepOutput}\n\n` +
                `Ignore this issue with: ${chalk_1.default.green(`ionic doctor ignore ${ailment.id}`)}`);
        }
        return false;
    });
}
