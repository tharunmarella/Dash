"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const guards_1 = require("../../../guards");
exports.ERROR_AILMENT_IGNORED = 'AILMENT_IGNORED';
exports.ERROR_AILMENT_SKIPPED = 'AILMENT_SKIPPED';
class Ailment {
    constructor({ client, config, log, project, shell, session }) {
        this.client = client;
        this.config = config;
        this.log = log;
        this.project = project;
        this.shell = shell;
        this.session = session;
    }
}
exports.Ailment = Ailment;
class AutomaticallyTreatableAilment extends Ailment {
    constructor(_a) {
        var { prompt } = _a, deps = tslib_1.__rest(_a, ["prompt"]);
        super(deps);
        this.prompt = prompt;
    }
    treat() {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            const config = yield this.config.load();
            const treatmentSteps = yield this.getTreatmentSteps();
            const stepOutput = treatmentSteps.map((step, i) => `    ${i + 1}) ${step.name}`).join('\n');
            this.log.warn(`${yield this.getMessage()}\n\nTo fix, the following step(s) need to be taken:\n\n${stepOutput}`);
            const CHOICE_YES = 'yes';
            const CHOICE_NO = 'no';
            const CHOICE_IGNORE = 'ignore';
            const choice = yield this.prompt({
                type: 'list',
                name: 'choice',
                message: `Fix automatically?`,
                choices: [
                    {
                        name: 'Yes',
                        value: CHOICE_YES,
                    },
                    {
                        name: 'No',
                        value: CHOICE_NO,
                    },
                    {
                        name: 'Ignore forever',
                        value: CHOICE_IGNORE,
                    },
                ],
            });
            if (choice === CHOICE_YES) {
                for (const i in treatmentSteps) {
                    const step = treatmentSteps[i];
                    try {
                        yield step.treat();
                    }
                    catch (e) {
                        if (!guards_1.isExitCodeException(e) || e.exitCode > 0) {
                            throw e;
                        }
                    }
                }
                return true;
            }
            else if (choice === CHOICE_NO) {
                throw exports.ERROR_AILMENT_SKIPPED;
            }
            else if (choice === CHOICE_IGNORE) {
                config.state.doctor.ignored.push(this.id);
                throw exports.ERROR_AILMENT_IGNORED;
            }
            return false;
        });
    }
}
exports.AutomaticallyTreatableAilment = AutomaticallyTreatableAilment;
class AilmentRegistry {
    constructor() {
        this._ailments = [];
    }
    register(ailment) {
        this._ailments.push(ailment);
    }
    get ailments() {
        return this._ailments;
    }
    get(id) {
        return this._ailments.find(a => a.id === id);
    }
}
exports.AilmentRegistry = AilmentRegistry;
