"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const Debug = require("debug");
const uuid_1 = require("./utils/uuid");
const helper_1 = require("./helper");
const debug = Debug('ionic:cli-utils:lib:telemetry');
const GA_CODE = 'UA-44023830-30';
let _gaTracker;
class Telemetry {
    constructor({ cli, config, client, getInfo, meta, project, session }) {
        this.cli = cli;
        this.client = client;
        this.config = config;
        this.getInfo = getInfo;
        this.meta = meta;
        this.project = project;
        this.session = session;
    }
    resetToken() {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            const config = yield this.config.load();
            config.tokens.telemetry = uuid_1.generateUUID();
        });
    }
    sendCommand(command, args) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            const config = yield this.config.load();
            if (config.telemetry) {
                yield helper_1.sendMessage({ meta: this.meta, config: this.config }, { type: 'telemetry', data: { command, args } });
            }
        });
    }
}
exports.Telemetry = Telemetry;
function getLeek({ config, version }) {
    return tslib_1.__awaiter(this, void 0, void 0, function* () {
        if (!_gaTracker) {
            const Leek = yield Promise.resolve().then(() => require('leek'));
            const c = yield config.load();
            if (!c.tokens.telemetry) {
                c.tokens.telemetry = uuid_1.generateUUID();
            }
            _gaTracker = new Leek({
                name: c.tokens.telemetry,
                trackingCode: GA_CODE,
                globalName: 'ionic',
                version,
                silent: c.telemetry !== true,
            });
        }
        return _gaTracker;
    });
}
function sendCommand({ cli, config, client, getInfo, session, project }, command, args) {
    return tslib_1.__awaiter(this, void 0, void 0, function* () {
        const messageList = [];
        const name = 'command execution';
        const prettyArgs = args.map(a => a.includes(' ') ? `"${a}"` : a);
        const message = messageList.concat([command], prettyArgs).join(' ');
        yield Promise.all([
            (() => tslib_1.__awaiter(this, void 0, void 0, function* () {
                const leek = yield getLeek({ config, version: cli.meta.pkg.version });
                try {
                    yield leek.track({ name, message });
                }
                catch (e) {
                    debug('leek track error', e);
                }
            }))(),
            (() => tslib_1.__awaiter(this, void 0, void 0, function* () {
                const c = yield config.load();
                const now = new Date().toISOString();
                let appId;
                const p = project.directory ? yield project.load() : undefined;
                if (p) {
                    appId = p.app_id;
                }
                const { req } = yield client.make('POST', '/events/metrics');
                const metric = {
                    'name': 'cli_command_metrics',
                    'timestamp': now,
                    'session_id': c.tokens.telemetry,
                    'source': 'cli',
                    'value': {
                        'command': command,
                        'arguments': prettyArgs.join(' '),
                        'version': cli.meta.pkg.version,
                        'node_version': process.version,
                        'app_id': appId,
                        'backend': 'pro',
                    },
                };
                const isLoggedIn = yield session.isLoggedIn();
                const v = [];
                const info = yield getInfo();
                const flattenedInfo = info.reduce((acc, currentValue) => acc.concat(currentValue), v);
                if (isLoggedIn) {
                    const token = yield session.getUserToken();
                    req.set('Authorization', `Bearer ${token}`);
                }
                const frameworkInfo = flattenedInfo.find(item => item.key === 'Ionic Framework');
                const npmInfo = flattenedInfo.find(item => item.key === 'npm');
                const osInfo = flattenedInfo.find(item => item.key === 'OS');
                const xcodeInfo = flattenedInfo.find(item => item.key === 'Xcode');
                const androidSdkInfo = flattenedInfo.find(item => item.key === 'Android SDK Tools');
                const cordovaInfo = flattenedInfo.find(item => item.key === 'Cordova CLI');
                const cordovaPlatformsInfo = flattenedInfo.find(item => item.key === 'Cordova Platforms');
                const appScriptsInfo = flattenedInfo.find(item => item.key === '@ionic/app-scripts');
                if (frameworkInfo) {
                    metric['value']['framework'] = frameworkInfo.value;
                }
                if (npmInfo) {
                    metric['value']['npm_version'] = npmInfo.value;
                }
                if (osInfo) {
                    metric['value']['os'] = osInfo.value;
                }
                if (xcodeInfo) {
                    metric['value']['xcode_version'] = xcodeInfo.value;
                }
                if (androidSdkInfo) {
                    metric['value']['android_sdk_version'] = androidSdkInfo.value;
                }
                if (cordovaInfo) {
                    metric['value']['cordova_version'] = cordovaInfo.value;
                }
                if (cordovaPlatformsInfo) {
                    metric['value']['cordova_platforms'] = cordovaPlatformsInfo.value;
                }
                if (appScriptsInfo) {
                    metric['value']['app_scripts_version'] = appScriptsInfo.value;
                }
                debug('metric: %o', metric);
                req.send({
                    'metrics': [metric],
                    'sent_at': now,
                });
                try {
                    yield client.do(req);
                }
                catch (e) {
                    debug('metric send error', e);
                }
            }))(),
        ]);
    });
}
exports.sendCommand = sendCommand;
