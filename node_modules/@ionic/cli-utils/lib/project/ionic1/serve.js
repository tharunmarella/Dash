"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const path = require("path");
const chalk_1 = require("chalk");
const Debug = require("debug");
const lodash = require("lodash");
const through2 = require("through2");
const split2 = require("split2");
const string_1 = require("@ionic/cli-framework/utils/string");
const constants_1 = require("../../../constants");
const errors_1 = require("../../errors");
const serve_1 = require("../../serve");
exports.DEFAULT_PROGRAM = 'ionic-v1';
const IONIC_V1_SERVE_CONNECTIVITY_TIMEOUT = 5000; // ms
const debug = Debug('ionic:cli-utils:lib:project:ionic1');
const WATCH_PATTERNS = [
    'scss/**/*',
    'www/**/*',
    '!www/lib/**/*',
    '!www/**/*.map',
];
function proxyConfigToMiddlewareConfig(proxy) {
    const config = {
        pathRewrite: { [proxy.path]: '' },
        target: proxy.proxyUrl,
    };
    if (proxy.proxyNoAgent) {
        config.agent = false; // TODO: type issue
    }
    if (proxy.rejectUnauthorized === false) {
        config.secure = false;
    }
    return config;
}
class ServeRunner extends serve_1.ServeRunner {
    getCommandMetadata() {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            return {
                options: [
                    {
                        name: 'consolelogs',
                        description: 'Print app console logs to Ionic CLI',
                        type: Boolean,
                        aliases: ['c'],
                    },
                    {
                        name: 'serverlogs',
                        description: 'Print dev server logs to Ionic CLI',
                        type: Boolean,
                        aliases: ['s'],
                        groups: [constants_1.OptionGroup.Hidden],
                    },
                    {
                        name: 'livereload-port',
                        description: 'Use specific port for live-reload',
                        default: serve_1.DEFAULT_LIVERELOAD_PORT.toString(),
                        aliases: ['r'],
                        groups: [constants_1.OptionGroup.Advanced],
                    },
                    {
                        name: 'dev-logger-port',
                        description: 'Use specific port for dev server communication',
                        default: serve_1.DEFAULT_DEV_LOGGER_PORT.toString(),
                        groups: [constants_1.OptionGroup.Advanced],
                    },
                ],
            };
        });
    }
    createOptionsFromCommandLine(inputs, options) {
        const baseOptions = super.createOptionsFromCommandLine(inputs, options);
        const livereloadPort = string_1.str2num(options['livereload-port'], serve_1.DEFAULT_LIVERELOAD_PORT);
        const notificationPort = string_1.str2num(options['dev-logger-port'], serve_1.DEFAULT_DEV_LOGGER_PORT);
        return Object.assign({}, baseOptions, { consolelogs: options['consolelogs'] ? true : false, serverlogs: options['serverlogs'] ? true : false, livereloadPort,
            notificationPort });
    }
    serveProject(options) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            const { isHostConnectable } = yield Promise.resolve().then(() => require('../../utils/network'));
            const [externalIP, availableInterfaces] = yield this.selectExternalIP(options);
            const { port, livereloadPort, notificationPort } = yield this.findOpenPorts(options.address, options);
            options.port = port;
            options.livereloadPort = livereloadPort;
            options.notificationPort = notificationPort;
            const details = [
                `address: ${chalk_1.default.bold(options.address)}`,
                `port: ${chalk_1.default.bold(String(port))}`,
                `dev server port: ${chalk_1.default.bold(String(notificationPort))}`,
            ];
            if (options.livereload) {
                details.push(`livereload port: ${chalk_1.default.bold(String(livereloadPort))}`);
            }
            const { program } = yield this.serveCommandWrapper(options);
            debug('waiting for connectivity with ionic-v1 (%dms timeout)', IONIC_V1_SERVE_CONNECTIVITY_TIMEOUT);
            yield isHostConnectable('localhost', port, IONIC_V1_SERVE_CONNECTIVITY_TIMEOUT);
            return {
                custom: program !== exports.DEFAULT_PROGRAM,
                protocol: 'http',
                localAddress: 'localhost',
                externalAddress: externalIP,
                externalNetworkInterfaces: availableInterfaces,
                port,
                externallyAccessible: ![serve_1.BIND_ALL_ADDRESS, ...serve_1.LOCAL_ADDRESSES].includes(externalIP),
            };
        });
    }
    serveCommandWrapper(options) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            const { promptToInstallPkg } = yield Promise.resolve().then(() => require('../../utils/npm'));
            const project = yield this.env.project.load();
            const wwwDir = yield this.env.project.getSourceDir();
            const proxies = project.proxies && options.proxy ? project.proxies.map(p => (Object.assign({ mount: p.path }, proxyConfigToMiddlewareConfig(p)))) : [];
            if (!project.watchPatterns || project.watchPatterns.length === 1 && project.watchPatterns[0] === 'scss/**/*') {
                project.watchPatterns = WATCH_PATTERNS;
            }
            debug(`Watch patterns: ${project.watchPatterns.map(v => chalk_1.default.bold(v)).join(', ')}`);
            const cmdopts = lodash.assign({ wwwDir, watchPatterns: project.watchPatterns, proxies }, options);
            try {
                return yield this.servecmd(cmdopts);
            }
            catch (e) {
                if (!(e instanceof errors_1.ServeCommandNotFoundException)) {
                    throw e;
                }
                const pkg = '@ionic/v1-util';
                this.env.log.nl();
                this.env.log.warn(`Looks like ${chalk_1.default.green(pkg)} isn't installed in this project.\n` +
                    `This package is required for ${chalk_1.default.green('ionic serve')} as of CLI 4.0. For more details, please see the CHANGELOG: ${chalk_1.default.bold('https://github.com/ionic-team/ionic-cli/blob/master/CHANGELOG.md#4.0.0')}`);
                const installed = yield promptToInstallPkg(this.env, { pkg, saveDev: true });
                if (!installed) {
                    throw new errors_1.FatalException(`${chalk_1.default.green(pkg)} is required for ${chalk_1.default.green('ionic serve')} to work properly.`);
                }
                return this.servecmd(cmdopts);
            }
        });
    }
    servecmd(options) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            const { pkgManagerArgs } = yield Promise.resolve().then(() => require('../../utils/npm'));
            const { registerShutdownFunction } = yield Promise.resolve().then(() => require('../../process'));
            const config = yield this.env.config.load();
            const pkg = yield this.env.project.loadPackageJson();
            const { npmClient } = config;
            const workingDir = this.env.project.directory;
            const networkArgs = ['--host', options.address, '--port', String(options.port), '--lr-port', String(options.livereloadPort), '--dev-port', String(options.notificationPort)];
            const watchPatternsArgs = lodash.flatten(options.watchPatterns.map(p => ['-w', p]));
            const proxiesArgs = lodash.flatten(options.proxies.map(p => ['-p', JSON.stringify(p)]));
            let program = exports.DEFAULT_PROGRAM;
            let args = [...networkArgs, ...watchPatternsArgs, ...proxiesArgs];
            const shellOptions = { cwd: workingDir, env: Object.assign({ FORCE_COLOR: chalk_1.default.enabled ? '1' : '0' }, process.env) };
            debug(`Looking for ${chalk_1.default.cyan(serve_1.SERVE_SCRIPT)} npm script.`);
            if (pkg.scripts && pkg.scripts[serve_1.SERVE_SCRIPT]) {
                debug(`Invoking ${chalk_1.default.cyan(serve_1.SERVE_SCRIPT)} npm script.`);
                const [pkgManager, ...pkgArgs] = yield pkgManagerArgs({ npmClient, shell: this.env.shell }, { command: 'run', script: serve_1.SERVE_SCRIPT, scriptArgs: [...args] });
                program = pkgManager;
                args = pkgArgs;
            }
            else {
                const v1utilArgs = ['serve', path.relative(workingDir, options.wwwDir)];
                if (options.consolelogs) {
                    v1utilArgs.push('-c');
                }
                args = [...v1utilArgs, ...args];
            }
            const p = yield this.env.shell.spawn(program, args, shellOptions);
            return new Promise((resolve, reject) => {
                p.on('error', (err) => {
                    if (program === exports.DEFAULT_PROGRAM && err.code === 'ENOENT') {
                        reject(new errors_1.ServeCommandNotFoundException(`${chalk_1.default.bold(exports.DEFAULT_PROGRAM)} command not found.`));
                    }
                    else {
                        reject(err);
                    }
                });
                registerShutdownFunction(() => p.kill());
                const log = this.env.log.clone({ prefix: chalk_1.default.dim(`[${program === exports.DEFAULT_PROGRAM ? 'v1' : program}]`), wrap: false });
                const ws = log.createWriteStream();
                if (program === exports.DEFAULT_PROGRAM) {
                    const stdoutFilter = through2(function (chunk, enc, callback) {
                        const str = chunk.toString();
                        if (str.includes('server running')) {
                            resolve({ program });
                        }
                        else {
                            this.push(chunk);
                        }
                        callback();
                    });
                    p.stdout.pipe(split2()).pipe(stdoutFilter).pipe(ws);
                    p.stderr.pipe(split2()).pipe(ws);
                }
                else {
                    p.stdout.pipe(split2()).pipe(ws);
                    p.stderr.pipe(split2()).pipe(ws);
                    resolve({ program });
                }
            });
        });
    }
    findOpenPorts(address, ports) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            const { ERROR_NETWORK_ADDRESS_NOT_AVAIL, findClosestOpenPort } = yield Promise.resolve().then(() => require('../../utils/network'));
            try {
                const [port, livereloadPort, notificationPort] = yield Promise.all([
                    findClosestOpenPort(ports.port, '0.0.0.0'),
                    findClosestOpenPort(ports.livereloadPort, '0.0.0.0'),
                    findClosestOpenPort(ports.notificationPort, '0.0.0.0'),
                ]);
                if (ports.port !== port) {
                    debug(`Port ${chalk_1.default.bold(String(ports.port))} taken, using ${chalk_1.default.bold(String(port))}.`);
                    ports.port = port;
                }
                if (ports.livereloadPort !== livereloadPort) {
                    debug(`Port ${chalk_1.default.bold(String(ports.livereloadPort))} taken, using ${chalk_1.default.bold(String(livereloadPort))}.`);
                    ports.livereloadPort = livereloadPort;
                }
                if (ports.notificationPort !== notificationPort) {
                    debug(`Port ${chalk_1.default.bold(String(ports.notificationPort))} taken, using ${chalk_1.default.bold(String(notificationPort))}.`);
                    ports.notificationPort = notificationPort;
                }
                return { port, livereloadPort, notificationPort };
            }
            catch (e) {
                if (e !== ERROR_NETWORK_ADDRESS_NOT_AVAIL) {
                    throw e;
                }
                throw new errors_1.FatalException(`${chalk_1.default.green(address)} is not available--cannot bind.`);
            }
        });
    }
}
exports.ServeRunner = ServeRunner;
