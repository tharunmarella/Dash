"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const chalk_1 = require("chalk");
const Debug = require("debug");
const lodash = require("lodash");
const through2 = require("through2");
const split2 = require("split2");
const cli_framework_1 = require("@ionic/cli-framework");
const generate_1 = require("../../generate");
const errors_1 = require("../../errors");
const debug = Debug('ionic:cli-utils:lib:project:angular:generate');
const IONIC_GENERATOR_TYPES = ['page'];
const ANGULAR_GENERATOR_TYPES = ['class', 'component', 'directive', 'enum', 'guard', 'interface', 'module', 'pipe', 'service'];
const GENERATOR_TYPES = [...IONIC_GENERATOR_TYPES, ...ANGULAR_GENERATOR_TYPES];
class GenerateRunner extends generate_1.GenerateRunner {
    specializeCommandMetadata(metadata) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            return Object.assign({}, metadata, { groups: [], description: `Generate Angular classes such as pages, components, directives, services, etc.`, longDescription: `
Automatically create components for your Ionic app.

This command uses the Angular CLI to generate components. Not all component generation options are listed.

 - For a detailed list of options for each generator, use ${chalk_1.default.green('ng generate <type> --help')}.
 - For ${IONIC_GENERATOR_TYPES.map(t => chalk_1.default.green(t)).join(', ')} types, use ${chalk_1.default.green('ng generate <type> --help --collection @ionic/schematics-angular')}.
      `, inputs: [
                    {
                        name: 'type',
                        description: `The type of generator (e.g. ${GENERATOR_TYPES.map(t => chalk_1.default.green(t)).join(', ')})`,
                        validators: [cli_framework_1.validators.required, cli_framework_1.contains(GENERATOR_TYPES, {})],
                    },
                    {
                        name: 'name',
                        description: 'The name of the component being generated',
                        validators: [cli_framework_1.validators.required],
                    },
                ], options: [
                    {
                        name: 'dry-run',
                        description: 'Run generate without making any file changes',
                        type: Boolean,
                        aliases: ['d'],
                    },
                    {
                        name: 'force',
                        description: 'Force overwriting of files',
                        type: Boolean,
                        aliases: ['f'],
                    },
                ] });
        });
    }
    ensureCommandLine(inputs, options) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            if (!inputs[0]) {
                const type = yield this.env.prompt({
                    type: 'list',
                    name: 'type',
                    message: 'What would you like to generate:',
                    choices: GENERATOR_TYPES,
                });
                inputs[0] = type;
            }
            if (!inputs[1]) {
                const name = yield this.env.prompt({
                    type: 'input',
                    name: 'name',
                    message: 'What should the name be?',
                    validate: v => cli_framework_1.validators.required(v),
                });
                inputs[1] = name;
            }
        });
    }
    createOptionsFromCommandLine(inputs, options) {
        const baseOptions = super.createOptionsFromCommandLine(inputs, options);
        return Object.assign({}, lodash.omit(options, '_', '--', 'dry-run', 'd', 'force', 'f'), baseOptions, { force: options['force'] ? true : false, dryRun: options['dry-run'] ? true : false });
    }
    run(options) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            try {
                yield this.generateComponent(options.type, options.name, lodash.omit(options, 'type', 'name'));
            }
            catch (e) {
                debug(e);
                throw new errors_1.FatalException(`Could not generate ${chalk_1.default.green(options.type)}.`);
            }
            this.env.log.ok(`Generated ${chalk_1.default.green(options.type)}!`);
        });
    }
    generateComponent(type, name, options) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            const { registerShutdownFunction } = yield Promise.resolve().then(() => require('../../process'));
            if (type === 'page') {
                options.collection = '@ionic/schematics-angular';
            }
            const ngArgs = cli_framework_1.unparseArgs(Object.assign({ _: ['generate', type, name] }, options), {});
            const shellOptions = { cwd: this.env.project.directory, env: Object.assign({ FORCE_COLOR: chalk_1.default.enabled ? '1' : '0' }, process.env) };
            const p = yield this.env.shell.spawn('ng', ngArgs, shellOptions);
            return new Promise((resolve, reject) => {
                let errorsEncountered = false;
                p.on('error', err => {
                    reject(err);
                });
                p.on('exit', code => {
                    if (code === 0) {
                        if (errorsEncountered) {
                            reject(new Error(`Angular CLI encountered errors while generating components.`));
                        }
                        else {
                            resolve();
                        }
                    }
                    else {
                        reject(new Error(`Angular CLI exited with error code: ${code}`));
                    }
                });
                registerShutdownFunction(() => p.kill());
                const log = this.env.log.clone({ wrap: false });
                const ws = log.createWriteStream();
                const stdoutStream = through2(function (chunk, env, callback) {
                    const str = chunk.toString();
                    if (str.includes('error!')) {
                        errorsEncountered = true;
                    }
                    this.push(chunk);
                    callback();
                });
                p.stdout.pipe(split2()).pipe(stdoutStream).pipe(ws);
                p.stderr.pipe(split2()).pipe(ws);
            });
        });
    }
}
exports.GenerateRunner = GenerateRunner;
