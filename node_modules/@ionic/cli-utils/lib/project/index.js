"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const path = require("path");
const chalk_1 = require("chalk");
const Debug = require("debug");
const lodash = require("lodash");
const fs_1 = require("@ionic/cli-framework/utils/fs");
const format_1 = require("@ionic/cli-framework/utils/format");
const npm_1 = require("@ionic/cli-framework/utils/npm");
const config_1 = require("../config");
const errors_1 = require("../errors");
const integrations_1 = require("../integrations");
const debug = Debug('ionic:cli-utils:lib:project');
exports.PROJECT_FILE = 'ionic.config.json';
exports.PROJECT_FILE_LEGACY = 'ionic.project';
exports.PROJECT_TYPES = ['angular', 'ionic-angular', 'ionic1', 'custom'];
class BaseProject extends config_1.BaseConfig {
    constructor(dir, file, { config, log, shell, tasks }) {
        super(dir, file);
        this.integrations = [];
        this.config = config;
        this.log = log;
        this.shell = shell;
        this.tasks = tasks;
    }
    static determineType(projectDir, deps) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            const projectFilePath = path.resolve(projectDir, exports.PROJECT_FILE);
            let projectFile;
            try {
                projectFile = yield fs_1.fsReadJsonFile(projectFilePath);
            }
            catch (e) {
                // ignore
            }
            if (projectFile && projectFile.type && exports.PROJECT_TYPES.includes(projectFile.type)) {
                debug(`Project type from config: ${chalk_1.default.bold(prettyProjectName(projectFile.type))} ${projectFile.type ? chalk_1.default.bold(`(${projectFile.type})`) : ''}`);
                return projectFile.type;
            }
            for (const projectType of exports.PROJECT_TYPES) {
                const p = yield BaseProject.createFromProjectType(projectDir, exports.PROJECT_FILE, deps, projectType);
                if (yield p.detected()) {
                    debug(`Project type detected: ${chalk_1.default.bold(prettyProjectName(p.type))} ${p.type ? chalk_1.default.bold(`(${p.type})`) : ''}`);
                    return p.type;
                }
            }
            const listWrapOptions = { width: format_1.TTY_WIDTH - 8 - 3, indentation: 1 };
            // TODO: move some of this to the CLI docs
            deps.log.error(`Could not determine project type (project config: ${chalk_1.default.bold(format_1.prettyPath(projectFilePath))}).\n` +
                `- ${format_1.wordWrap(`For ${chalk_1.default.bold(prettyProjectName('angular'))} projects, make sure ${chalk_1.default.green('@ionic/angular')} is listed as a dependency in ${chalk_1.default.bold('package.json')}.`, listWrapOptions)}\n` +
                `- ${format_1.wordWrap(`For ${chalk_1.default.bold(prettyProjectName('ionic-angular'))} projects, make sure ${chalk_1.default.green('ionic-angular')} is listed as a dependency in ${chalk_1.default.bold('package.json')}.`, listWrapOptions)}\n` +
                `- ${format_1.wordWrap(`For ${chalk_1.default.bold(prettyProjectName('ionic1'))} projects, make sure ${chalk_1.default.green('ionic')} is listed as a dependency in ${chalk_1.default.bold('bower.json')}.`, listWrapOptions)}\n\n` +
                `Alternatively, set ${chalk_1.default.bold('type')} attribute in ${chalk_1.default.bold(exports.PROJECT_FILE)} to one of: ${exports.PROJECT_TYPES.map(v => chalk_1.default.green(v)).join(', ')}.\n\n` +
                `If the Ionic CLI does not know what type of project this is, ${chalk_1.default.green('ionic build')}, ${chalk_1.default.green('ionic serve')}, and other commands may not work. You can use the ${chalk_1.default.green('custom')} project type if that's okay.`);
        });
    }
    static createFromProjectType(dir, file, deps, type) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            let project;
            if (type === 'angular') {
                const { Project } = yield Promise.resolve().then(() => require('./angular'));
                project = new Project(dir, file, deps);
            }
            else if (type === 'ionic-angular') {
                const { Project } = yield Promise.resolve().then(() => require('./ionic-angular'));
                project = new Project(dir, file, deps);
            }
            else if (type === 'ionic1') {
                const { Project } = yield Promise.resolve().then(() => require('./ionic1'));
                project = new Project(dir, file, deps);
            }
            else if (type === 'custom') {
                const { Project } = yield Promise.resolve().then(() => require('./custom'));
                project = new Project(dir, file, deps);
            }
            else {
                throw new errors_1.FatalException(`Bad project type: ${chalk_1.default.bold(type)}`); // TODO?
            }
            yield project.refreshIntegrations();
            return project;
        });
    }
    refreshIntegrations() {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            const p = yield this.load();
            const projectIntegrations = Object.keys(p.integrations); // TODO
            const integrationNames = projectIntegrations.filter(n => {
                const i = p.integrations[n];
                return i && i.enabled !== false;
            });
            this.integrations = yield Promise.all(integrationNames.map((name) => tslib_1.__awaiter(this, void 0, void 0, function* () {
                return integrations_1.BaseIntegration.createFromName({
                    config: this.config,
                    project: this,
                    shell: this.shell,
                    tasks: this.tasks,
                }, name);
            })));
        });
    }
    loadAppId() {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            const p = yield this.load();
            if (!p.app_id) {
                throw new errors_1.FatalException(`Your project file (${chalk_1.default.bold(format_1.prettyPath(this.filePath))}) does not contain '${chalk_1.default.bold('app_id')}'. ` +
                    `Run ${chalk_1.default.green('ionic link')}.`);
            }
            return p.app_id;
        });
    }
    get packageJsonPath() {
        return path.resolve(this.directory, 'package.json');
    }
    loadPackageJson() {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            if (!this.packageJsonFile) {
                try {
                    this.packageJsonFile = yield npm_1.readPackageJsonFile(this.packageJsonPath);
                }
                catch (e) {
                    if (e === fs_1.ERROR_FILE_INVALID_JSON) {
                        throw new errors_1.FatalException(`Could not parse ${chalk_1.default.bold('package.json')}. Is it a valid JSON file?`);
                    }
                    else if (e === npm_1.ERROR_INVALID_PACKAGE_JSON) {
                        throw new errors_1.FatalException(`The ${chalk_1.default.bold('package.json')} file seems malformed.`);
                    }
                    throw e; // Probably file not found
                }
            }
            return this.packageJsonFile;
        });
    }
    provideDefaults(o) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            const results = lodash.cloneDeep(o);
            if (!results.name) {
                results.name = '';
            }
            if (!results.app_id) {
                results.app_id = '';
            }
            if (!results.integrations) {
                results.integrations = {};
            }
            if (!results.hooks) {
                results.hooks = {};
            }
            if (!results.type) {
                results.type = this.type;
            }
            delete results.integrations.gulp;
            delete results.gulp;
            delete results.projectTypeId;
            delete results.typescript;
            delete results.v2;
            return results;
        });
    }
    is(j) {
        return j
            && typeof j.name === 'string'
            && typeof j.app_id === 'string'
            && typeof j.integrations === 'object'
            && typeof j.hooks === 'object';
    }
    getInfo() {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            return lodash.flatten(yield Promise.all(this.integrations.map((i) => tslib_1.__awaiter(this, void 0, void 0, function* () { return i.getInfo(); }))));
        });
    }
    getSourceDir() {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            return path.resolve(this.directory, 'src');
        });
    }
    personalize(details) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            const { appName, displayName, description, version } = details;
            const project = yield this.load();
            project.name = displayName ? displayName : appName;
            yield this.save();
            const pkg = yield this.loadPackageJson();
            pkg.name = appName;
            pkg.version = version ? version : '0.0.1';
            pkg.description = description ? description : 'An Ionic project';
            yield fs_1.fsWriteJsonFile(this.packageJsonPath, pkg, { encoding: 'utf8' });
            yield Promise.all(this.integrations.map((i) => tslib_1.__awaiter(this, void 0, void 0, function* () { return i.personalize(details); })));
        });
    }
    getAilmentRegistry(deps) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            const { AilmentRegistry, registerAilments } = yield Promise.resolve().then(() => require('../doctor/ailments'));
            const registry = new AilmentRegistry();
            registerAilments(registry, deps);
            return registry;
        });
    }
}
exports.BaseProject = BaseProject;
/**
 * This is a gross hack.
 *
 * TODO: minimize IonicEnvironment & `env.project.directory` usage, make
 * `env.project` undefined when outside a project.
 */
class OutsideProject extends config_1.BaseConfig {
    constructor() {
        super(...arguments);
        this.type = undefined;
        this.integrations = [];
    }
    is(j) {
        return false;
    }
    _createError() {
        return new errors_1.FatalException(`Attempted to load an Ionic project outside a detected project directory.` +
            `Would you mind reporting this issue? ${chalk_1.default.bold('https://github.com/ionic-team/ionic-cli/issues/')}`);
    }
    detected() {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            return true;
        });
    }
    getInfo() {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            return [];
        });
    }
    getSourceDir() {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            throw this._createError();
        });
    }
    loadAppId() {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            throw this._createError();
        });
    }
    loadPackageJson() {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            throw this._createError();
        });
    }
    provideDefaults() {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            throw this._createError();
        });
    }
    personalize() {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            throw this._createError();
        });
    }
    refreshIntegrations() {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            throw this._createError();
        });
    }
    getAilmentRegistry() {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            throw this._createError();
        });
    }
}
exports.OutsideProject = OutsideProject;
function prettyProjectName(type) {
    if (!type) {
        return 'Unknown';
    }
    if (type === 'angular') {
        return 'Ionic Angular v4+';
    }
    else if (type === 'ionic-angular') {
        return 'Ionic Angular v2/v3';
    }
    else if (type === 'ionic1') {
        return 'Ionic 1';
    }
    return type;
}
exports.prettyProjectName = prettyProjectName;
