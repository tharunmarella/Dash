"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const os = require("os");
const path = require("path");
const chalk_1 = require("chalk");
const Debug = require("debug");
const fs_1 = require("@ionic/cli-framework/utils/fs");
const fn_1 = require("@ionic/cli-framework/utils/fn");
const errors_1 = require("../errors");
var guards_1 = require("../../guards");
exports.INTEGRATION_NAMES = guards_1.INTEGRATION_NAMES;
const debug = Debug('ionic:cli-utils:lib:integrations');
class BaseIntegration {
    constructor({ config, project, shell, tasks }) {
        this.config = config;
        this.project = project;
        this.shell = shell;
        this.tasks = tasks;
    }
    static createFromName(deps, name) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            if (name === 'cordova') {
                const { Integration } = yield Promise.resolve().then(() => require('./cordova'));
                return new Integration(deps);
            }
            throw new errors_1.IntegrationNotFoundException(`Bad integration name: ${chalk_1.default.bold(name)}`); // TODO?
        });
    }
    getConfig() {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            const p = yield this.project.load();
            return p.integrations[this.name];
        });
    }
    enable() {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            const project = yield this.project.load();
            const integrationConfig = (yield this.getConfig()) || {};
            if (integrationConfig.enabled === false) {
                integrationConfig.enabled = true;
            }
            project.integrations[this.name] = integrationConfig;
            yield this.project.refreshIntegrations();
            yield this.project.save();
        });
    }
    disable() {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            const project = yield this.project.load();
            const integrationConfig = (yield this.getConfig()) || {};
            integrationConfig.enabled = false;
            project.integrations[this.name] = integrationConfig;
            yield this.project.refreshIntegrations();
            yield this.project.save();
        });
    }
    personalize(details) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            // overwritten by subclasses
        });
    }
    add(opts) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            if (!this.archiveUrl) {
                return;
            }
            const onFileCreate = opts && opts.onFileCreate ? opts.onFileCreate : fn_1.noop;
            const conflictHandler = opts && opts.conflictHandler ? opts.conflictHandler : () => tslib_1.__awaiter(this, void 0, void 0, function* () { return false; });
            const { download } = yield Promise.resolve().then(() => require('../http'));
            const { createTarExtraction } = yield Promise.resolve().then(() => require('../utils/archive'));
            const task = this.tasks.next(`Downloading integration ${chalk_1.default.green(this.name)}`);
            const tmpdir = path.resolve(os.tmpdir(), `ionic-integration-${this.name}`);
            // TODO: etag
            if (yield fs_1.pathExists(tmpdir)) {
                yield fs_1.removeDirectory(tmpdir);
            }
            yield fs_1.fsMkdirp(tmpdir, 0o777);
            const ws = yield createTarExtraction({ cwd: tmpdir });
            const c = yield this.config.load();
            yield download(this.archiveUrl, ws, {
                progress: (loaded, total) => task.progress(loaded, total),
                ssl: c.ssl,
            });
            this.tasks.end();
            const contents = yield fs_1.readDir(tmpdir);
            const blacklist = [];
            debug(`Integration files downloaded to ${chalk_1.default.bold(tmpdir)} (files: ${contents.map(f => chalk_1.default.bold(f)).join(', ')})`);
            for (const f of contents) {
                const projectf = path.resolve(this.project.directory, f);
                try {
                    const stats = yield fs_1.fsStat(projectf);
                    const overwrite = yield conflictHandler(projectf, stats);
                    if (!overwrite) {
                        blacklist.push(f);
                    }
                }
                catch (e) {
                    if (e.code !== 'ENOENT') {
                        throw e;
                    }
                }
            }
            this.tasks.next(`Copying integrations files to project`);
            debug(`Blacklist: ${blacklist.map(f => chalk_1.default.bold(f)).join(', ')}`);
            yield fs_1.copyDirectory(tmpdir, this.project.directory, {
                filter: f => {
                    if (f === tmpdir) {
                        return true;
                    }
                    const projectf = f.substring(tmpdir.length + 1);
                    for (const item of blacklist) {
                        if (item.slice(-1) === '/' && `${projectf}/` === item) {
                            return false;
                        }
                        if (projectf.startsWith(item)) {
                            return false;
                        }
                    }
                    onFileCreate(projectf);
                    return true;
                },
            });
            this.tasks.end();
            yield this.enable();
        });
    }
}
exports.BaseIntegration = BaseIntegration;
