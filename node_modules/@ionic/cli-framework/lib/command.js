"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const lodash = require("lodash");
const string_1 = require("../utils/string");
const guards_1 = require("../guards");
const errors_1 = require("./errors");
const validators_1 = require("./validators");
class BaseCommand {
    constructor(namespace) {
        this.namespace = namespace;
    }
    validate(argv) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            const metadata = yield this.getMetadata();
            if (!metadata.inputs) {
                return;
            }
            const errors = [];
            for (const i in metadata.inputs) {
                const input = metadata.inputs[i];
                if (input.validators && input.validators.length > 0) {
                    try {
                        validators_1.validate(argv[i], input.name, [...input.validators]);
                    }
                    catch (e) {
                        if (!(e instanceof errors_1.InputValidationError)) {
                            throw e;
                        }
                        errors.push(e.errors);
                    }
                }
            }
            if (errors.length > 0) {
                throw new errors_1.InputValidationError('Invalid inputs.', lodash.flatten(errors));
            }
        });
    }
}
exports.BaseCommand = BaseCommand;
exports.CommandMapDefault = Symbol('default');
class BaseCommandMap extends Map {
    getAliases() {
        const aliasmap = new Map();
        // TODO: waiting for https://github.com/Microsoft/TypeScript/issues/18562
        const aliases = [...this.entries()].filter(([, v]) => guards_1.isCommandMapKey(v));
        aliases.forEach(([alias, cmd]) => {
            const cmdaliases = aliasmap.get(cmd) || [];
            cmdaliases.push(alias);
            aliasmap.set(cmd, cmdaliases);
        });
        return aliasmap;
    }
    resolveAliases(cmdName) {
        const r = this.get(cmdName);
        if (typeof r !== 'string') {
            return r;
        }
        return this.resolveAliases(r);
    }
}
exports.BaseCommandMap = BaseCommandMap;
class BaseNamespaceMap extends Map {
}
exports.BaseNamespaceMap = BaseNamespaceMap;
class BaseNamespace {
    constructor(parent = undefined) {
        this.parent = parent;
    }
    // TODO: https://github.com/Microsoft/TypeScript/issues/9659
    getNamespaces() {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            return new BaseNamespaceMap();
        });
    }
    // TODO: https://github.com/Microsoft/TypeScript/issues/9659
    getCommands() {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            return new BaseCommandMap();
        });
    }
    /**
     * Recursively inspect inputs supplied to walk down all the tree of
     * namespaces available to find the command that we will execute or the
     * right-most namespace matched if the command is not found.
     */
    locate(argv) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            const _locate = (inputs, parent, path) => tslib_1.__awaiter(this, void 0, void 0, function* () {
                const [key] = inputs;
                const children = yield parent.getNamespaces();
                const nsgetter = children.get(key);
                if (!nsgetter) {
                    const commands = yield parent.getCommands();
                    const cmdgetter = commands.resolveAliases(key);
                    if (cmdgetter) {
                        const cmd = yield cmdgetter();
                        return { args: inputs.slice(1), obj: cmd, path: [...path, [key, cmd]] };
                    }
                    const defaultcmdgetter = commands.get(exports.CommandMapDefault);
                    if (defaultcmdgetter && typeof defaultcmdgetter !== 'string') {
                        const cmd = yield defaultcmdgetter();
                        if (path.length > 0) {
                            // The default command was found via the namespace, so we replace the
                            // previous path entry (the namespace which contains this default
                            // command) with the command itself.
                            path[path.length - 1][1] = cmd;
                        }
                        return { args: inputs, obj: cmd, path };
                    }
                    return { args: inputs, obj: parent, path };
                }
                const child = yield nsgetter();
                return _locate(inputs.slice(1), child, [...path, [key, child]]);
            });
            const metadata = yield this.getMetadata();
            // TODO: typescript complains about `this`. Calling this method on
            // BaseNamespace would be unsafe if the class weren't abstract. Typescript
            // bug? I may be wrong.
            return _locate(argv, this, [[metadata.name, this]]);
        });
    }
    /**
     * Get all command metadata in a flat structure.
     */
    getCommandMetadataList() {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            const _getCommandMetadataList = (parent, path) => tslib_1.__awaiter(this, void 0, void 0, function* () {
                const commandList = [];
                const commands = yield parent.getCommands();
                const nsAliases = commands.getAliases();
                // Gather all commands for a namespace and turn them into simple key value
                // objects. Also keep a record of the namespace path.
                yield Promise.all([...commands.entries()].map(([k, cmdgetter]) => tslib_1.__awaiter(this, void 0, void 0, function* () {
                    if (typeof cmdgetter === 'string') {
                        return;
                    }
                    const command = yield cmdgetter();
                    const aliases = nsAliases.get(k) || [];
                    const metadata = yield command.getMetadata();
                    const cmdPath = [...path];
                    if (typeof k === 'string') {
                        cmdPath.push([k, command]);
                    }
                    // TODO: can't use spread: https://github.com/Microsoft/TypeScript/pull/13288
                    const result = lodash.assign({}, metadata, { command, namespace: parent, aliases, path: cmdPath });
                    commandList.push(result);
                })));
                commandList.sort((a, b) => string_1.strcmp(a.name, b.name));
                let namespacedCommandList = [];
                const children = yield parent.getNamespaces();
                // If this namespace has children then get their commands
                if (children.size > 0) {
                    yield Promise.all([...children.entries()].map(([k, nsgetter]) => tslib_1.__awaiter(this, void 0, void 0, function* () {
                        const ns = yield nsgetter();
                        const cmds = yield _getCommandMetadataList(ns, [...path, [k, ns]]);
                        namespacedCommandList = namespacedCommandList.concat(cmds);
                    })));
                }
                return commandList.concat(namespacedCommandList);
            });
            // TODO: typescript complains about `this`. Calling this method on
            // BaseNamespace would be unsafe if the class weren't abstract. Typescript
            // bug? I may be wrong.
            return _getCommandMetadataList(this, []);
        });
    }
}
exports.BaseNamespace = BaseNamespace;
class Command extends BaseCommand {
}
exports.Command = Command;
class Namespace extends BaseNamespace {
}
exports.Namespace = Namespace;
class CommandMap extends BaseCommandMap {
}
exports.CommandMap = CommandMap;
class NamespaceMap extends BaseNamespaceMap {
}
exports.NamespaceMap = NamespaceMap;
/**
 * Given a command object, backtrack through the command's namespace to compile
 * a list of command path items which represents how the command was
 * found/constructed.
 */
function generateCommandPath(cmd) {
    return tslib_1.__awaiter(this, void 0, void 0, function* () {
        const ns = cmd.namespace;
        const cmdmeta = yield cmd.getMetadata();
        const _cmdpath = (namespace) => tslib_1.__awaiter(this, void 0, void 0, function* () {
            const nsmeta = yield namespace.getMetadata();
            const nspath = [nsmeta.name, namespace];
            if (!namespace.parent) {
                return [nspath];
            }
            return [...(yield _cmdpath(namespace.parent)), nspath];
        });
        return [...(yield _cmdpath(ns)), [cmdmeta.name, cmd]];
    });
}
exports.generateCommandPath = generateCommandPath;
