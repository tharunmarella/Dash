import { CommandInstanceInfo, CommandLineInputs, CommandLineOptions, CommandMapGetter, CommandMapKey, CommandMetadata, CommandMetadataInput, CommandMetadataOption, CommandPathItem, HydratedCommandMetadata, ICommand, ICommandMap, INamespace, INamespaceMap, NamespaceLocateResult, NamespaceMapGetter, NamespaceMetadata } from '../definitions';
export declare abstract class BaseCommand<C extends ICommand<C, N, M, I, O>, N extends INamespace<C, N, M, I, O>, M extends CommandMetadata<I, O>, I extends CommandMetadataInput, O extends CommandMetadataOption> {
    namespace: N;
    constructor(namespace: N);
    abstract getMetadata(): Promise<M>;
    abstract run(inputs: CommandLineInputs, options: CommandLineOptions, runtime?: CommandInstanceInfo<C, N, M, I, O>): Promise<void>;
    validate(argv: CommandLineInputs): Promise<void>;
}
export declare const CommandMapDefault: symbol;
export declare class BaseCommandMap<C extends ICommand<C, N, M, I, O>, N extends INamespace<C, N, M, I, O>, M extends CommandMetadata<I, O>, I extends CommandMetadataInput, O extends CommandMetadataOption> extends Map<CommandMapKey, string | CommandMapGetter<C, N, M, I, O>> implements ICommandMap<C, N, M, I, O> {
    getAliases(): Map<CommandMapKey, CommandMapKey[]>;
    resolveAliases(cmdName: string): undefined | CommandMapGetter<C, N, M, I, O>;
}
export declare class BaseNamespaceMap<C extends ICommand<C, N, M, I, O>, N extends INamespace<C, N, M, I, O>, M extends CommandMetadata<I, O>, I extends CommandMetadataInput, O extends CommandMetadataOption> extends Map<string, NamespaceMapGetter<C, N, M, I, O>> implements INamespaceMap<C, N, M, I, O> {
}
export declare abstract class BaseNamespace<C extends ICommand<C, N, M, I, O>, N extends INamespace<C, N, M, I, O>, M extends CommandMetadata<I, O>, I extends CommandMetadataInput, O extends CommandMetadataOption> implements INamespace<C, N, M, I, O> {
    parent: N | undefined;
    constructor(parent?: N | undefined);
    abstract getMetadata(): Promise<NamespaceMetadata>;
    getNamespaces(): Promise<INamespaceMap<C, N, M, I, O>>;
    getCommands(): Promise<ICommandMap<C, N, M, I, O>>;
    /**
     * Recursively inspect inputs supplied to walk down all the tree of
     * namespaces available to find the command that we will execute or the
     * right-most namespace matched if the command is not found.
     */
    locate(argv: string[]): Promise<NamespaceLocateResult<C, N, M, I, O>>;
    /**
     * Get all command metadata in a flat structure.
     */
    getCommandMetadataList(): Promise<(M & HydratedCommandMetadata<C, N, M, I, O>)[]>;
}
export declare abstract class Command extends BaseCommand<Command, Namespace, CommandMetadata, CommandMetadataInput, CommandMetadataOption> {
}
export declare abstract class Namespace extends BaseNamespace<Command, Namespace, CommandMetadata, CommandMetadataInput, CommandMetadataOption> {
}
export declare class CommandMap extends BaseCommandMap<Command, Namespace, CommandMetadata, CommandMetadataInput, CommandMetadataOption> {
}
export declare class NamespaceMap extends BaseNamespaceMap<Command, Namespace, CommandMetadata, CommandMetadataInput, CommandMetadataOption> {
}
/**
 * Given a command object, backtrack through the command's namespace to compile
 * a list of command path items which represents how the command was
 * found/constructed.
 */
export declare function generateCommandPath<C extends ICommand<C, N, M, I, O>, N extends INamespace<C, N, M, I, O>, M extends CommandMetadata<I, O>, I extends CommandMetadataInput, O extends CommandMetadataOption>(cmd: C): Promise<CommandPathItem<C, N, M, I, O>[]>;
